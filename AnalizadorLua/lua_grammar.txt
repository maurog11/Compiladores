Grammar:

Rule 0     S' -> chunk
Rule 1     chunk -> chunk2 laststat
Rule 2     chunk2 -> chunk2 stat optsemi
Rule 3     chunk2 -> stat optsemi
Rule 4     block -> chunk
Rule 5     optsemi -> empty
Rule 6     optsemi -> ;
Rule 7     stat -> LOCAL namelist = explist
Rule 8     stat -> LOCAL namelist
Rule 9     stat -> LOCAL FUNCTION name funcbody
Rule 10    stat -> FUNCTION funcname args
Rule 11    stat -> FUNCTION funcname funcbody
Rule 12    stat -> FOR namelist IN explist DO block END
Rule 13    stat -> FOR name = exp , exp , exp DO block END
Rule 14    stat -> FOR name = exp , exp DO block END
Rule 15    stat -> IF exp THEN block elseiflist _else END
Rule 16    stat -> REPEAT block UNTIL exp
Rule 17    stat -> { WHILE } exp { DO } block { END }
Rule 18    stat -> { DO } block { END }
Rule 19    stat -> functioncall
Rule 20    stat -> location = explist
Rule 21    elseiflist -> empty
Rule 22    elseiflist -> elseiflist elseif
Rule 23    elseiflist -> elseif
Rule 24    elseif -> ELSEIF exp THEN block
Rule 25    _else -> empty
Rule 26    _else -> ELSE block
Rule 27    laststat -> BREAK optsemi
Rule 28    laststat -> RETURN explist
Rule 29    laststat -> RETURN optsemi
Rule 30    funcname -> funcname2
Rule 31    funcname -> funcname2 : name
Rule 32    funcname2 -> funcname2 . name
Rule 33    funcname2 -> name
Rule 34    varlist -> var
Rule 35    varlist -> varlist , var
Rule 36    var -> prefixexp . name
Rule 37    var -> prefixexp [ exp ]
Rule 38    var -> name
Rule 39    location -> varlist
Rule 40    name -> NAME
Rule 41    namelist -> name
Rule 42    namelist -> namelist , name
Rule 43    explist -> explist , exp
Rule 44    explist -> exp
Rule 45    exp -> # exp  [precedence=left, level=7]
Rule 46    exp -> NOT exp  [precedence=left, level=7]
Rule 47    exp -> - exp  [precedence=left, level=7]
Rule 48    exp -> exp OR exp  [precedence=left, level=1]
Rule 49    exp -> exp AND exp  [precedence=left, level=2]
Rule 50    exp -> exp NE exp  [precedence=left, level=3]
Rule 51    exp -> exp EQ exp  [precedence=left, level=3]
Rule 52    exp -> exp GE exp  [precedence=left, level=3]
Rule 53    exp -> exp GT exp  [precedence=left, level=3]
Rule 54    exp -> exp LE exp  [precedence=left, level=3]
Rule 55    exp -> exp LT exp  [precedence=left, level=3]
Rule 56    exp -> exp CONCAT exp  [precedence=right, level=4]
Rule 57    exp -> exp % exp  [precedence=left, level=6]
Rule 58    exp -> exp ^ exp  [precedence=right, level=8]
Rule 59    exp -> exp / exp  [precedence=left, level=6]
Rule 60    exp -> exp * exp  [precedence=left, level=6]
Rule 61    exp -> exp - exp  [precedence=left, level=5]
Rule 62    exp -> exp + exp  [precedence=left, level=5]
Rule 63    exp -> tableconstructor
Rule 64    exp -> prefixexp
Rule 65    exp -> function
Rule 66    exp -> VARARG
Rule 67    exp -> NIL
Rule 68    exp -> NUMBER
Rule 69    exp -> STRING
Rule 70    exp -> TRUE
Rule 71    exp -> FALSE
Rule 72    prefixexp -> ( exp )
Rule 73    prefixexp -> functioncall
Rule 74    prefixexp -> var
Rule 75    functioncall -> prefixexp : name args
Rule 76    functioncall -> prefixexp args
Rule 77    args -> STRING
Rule 78    args -> tableconstructor
Rule 79    args -> ( explist )
Rule 80    args -> ( )
Rule 81    function -> FUNCTION funcbody
Rule 82    funcbody -> ( ) block END
Rule 83    funcbody -> ( parlist ) block END
Rule 84    parlist -> VARARG
Rule 85    parlist -> namelist , VARARG
Rule 86    parlist -> empty
Rule 87    parlist -> namelist
Rule 88    tableconstructor -> { }
Rule 89    tableconstructor -> { fieldlist }
Rule 90    fieldlist -> fieldlist2 optfieldsep
Rule 91    fieldlist2 -> fieldlist2 fieldsep field
Rule 92    fieldlist2 -> field
Rule 93    field -> exp
Rule 94    field -> NAME = exp
Rule 95    field -> [ exp ] = exp
Rule 96    optfieldsep -> empty
Rule 97    optfieldsep -> fieldsep
Rule 98    fieldsep -> ;
Rule 99    fieldsep -> ,
Rule 100   empty -> <empty>

Unused terminals:

    TDOT
    APPEND
    UMINUS

Terminals, with rules where they appear:

#                    : 45
%                    : 57
(                    : 72 79 80 82 83
)                    : 72 79 80 82 83
*                    : 60
+                    : 62
,                    : 13 13 14 35 42 43 85 99
-                    : 47 61
.                    : 32 36
/                    : 59
:                    : 31 75
;                    : 6 98
=                    : 7 13 14 20 94 95
AND                  : 49
APPEND               : 
BREAK                : 27
CONCAT               : 56
DO                   : 12 13 14 17 18
ELSE                 : 26
ELSEIF               : 24
END                  : 12 13 14 15 17 18 82 83
EQ                   : 51
FALSE                : 71
FOR                  : 12 13 14
FUNCTION             : 9 10 11 81
GE                   : 52
GT                   : 53
IF                   : 15
IN                   : 12
LE                   : 54
LOCAL                : 7 8 9
LT                   : 55
NAME                 : 40 94
NE                   : 50
NIL                  : 67
NOT                  : 46
NUMBER               : 68
OR                   : 48
REPEAT               : 16
RETURN               : 28 29
STRING               : 69 77
TDOT                 : 
THEN                 : 15 24
TRUE                 : 70
UMINUS               : 
UNTIL                : 16
VARARG               : 66 84 85
WHILE                : 17
[                    : 37 95
]                    : 37 95
^                    : 58
error                : 
{                    : 17 17 17 18 18 88 89
}                    : 17 17 17 18 18 88 89

Nonterminals, with rules where they appear:

_else                : 15
args                 : 10 75 76
block                : 12 13 14 15 16 17 18 24 26 82 83
chunk                : 4 0
chunk2               : 1 2
elseif               : 22 23
elseiflist           : 15 22
empty                : 5 21 25 86 96
exp                  : 13 13 13 14 14 15 16 17 24 37 43 44 45 46 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 72 93 94 95 95
explist              : 7 12 20 28 43 79
field                : 91 92
fieldlist            : 89
fieldlist2           : 90 91
fieldsep             : 91 97
funcbody             : 9 11 81
funcname             : 10 11
funcname2            : 30 31 32
function             : 65
functioncall         : 19 73
laststat             : 1
location             : 20
name                 : 9 13 14 31 32 33 36 38 41 42 75
namelist             : 7 8 12 42 85 87
optfieldsep          : 90
optsemi              : 2 3 27 29
parlist              : 83
prefixexp            : 36 37 64 75 76
stat                 : 2 3
tableconstructor     : 63 78
var                  : 34 35 74
varlist              : 35 39


state 0

    (0) S' -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    chunk                          shift and go to state 1
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 1

    (0) S' -> chunk .


state 2

    (1) chunk -> chunk2 . laststat
    (2) chunk2 -> chunk2 . stat optsemi
    (27) laststat -> . BREAK optsemi
    (28) laststat -> . RETURN explist
    (29) laststat -> . RETURN optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    BREAK           shift and go to state 20
    RETURN          shift and go to state 21
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    laststat                       shift and go to state 18
    stat                           shift and go to state 19
    name                           shift and go to state 6
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 3

    (3) chunk2 -> stat . optsemi
    (5) optsemi -> . empty
    (6) optsemi -> . ;
    (100) empty -> .
    ;               shift and go to state 24
    BREAK           reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    LOCAL           reduce using rule 100 (empty -> .)
    FUNCTION        reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    REPEAT          reduce using rule 100 (empty -> .)
    {               reduce using rule 100 (empty -> .)
    (               reduce using rule 100 (empty -> .)
    NAME            reduce using rule 100 (empty -> .)

    optsemi                        shift and go to state 22
    empty                          shift and go to state 23

state 4

    (7) stat -> LOCAL . namelist = explist
    (8) stat -> LOCAL . namelist
    (9) stat -> LOCAL . FUNCTION name funcbody
    (41) namelist -> . name
    (42) namelist -> . namelist , name
    (40) name -> . NAME
    FUNCTION        shift and go to state 26
    NAME            shift and go to state 17

    namelist                       shift and go to state 25
    name                           shift and go to state 27

state 5

    (10) stat -> FUNCTION . funcname args
    (11) stat -> FUNCTION . funcname funcbody
    (30) funcname -> . funcname2
    (31) funcname -> . funcname2 : name
    (32) funcname2 -> . funcname2 . name
    (33) funcname2 -> . name
    (40) name -> . NAME
    NAME            shift and go to state 17

    funcname                       shift and go to state 28
    funcname2                      shift and go to state 29
    name                           shift and go to state 30

state 6

    (38) var -> name .
    :               reduce using rule 38 (var -> name .)
    .               reduce using rule 38 (var -> name .)
    [               reduce using rule 38 (var -> name .)
    STRING          reduce using rule 38 (var -> name .)
    (               reduce using rule 38 (var -> name .)
    {               reduce using rule 38 (var -> name .)
    ,               reduce using rule 38 (var -> name .)
    =               reduce using rule 38 (var -> name .)
    THEN            reduce using rule 38 (var -> name .)
    OR              reduce using rule 38 (var -> name .)
    AND             reduce using rule 38 (var -> name .)
    NE              reduce using rule 38 (var -> name .)
    EQ              reduce using rule 38 (var -> name .)
    GE              reduce using rule 38 (var -> name .)
    GT              reduce using rule 38 (var -> name .)
    LE              reduce using rule 38 (var -> name .)
    LT              reduce using rule 38 (var -> name .)
    CONCAT          reduce using rule 38 (var -> name .)
    %               reduce using rule 38 (var -> name .)
    ^               reduce using rule 38 (var -> name .)
    /               reduce using rule 38 (var -> name .)
    *               reduce using rule 38 (var -> name .)
    -               reduce using rule 38 (var -> name .)
    +               reduce using rule 38 (var -> name .)
    )               reduce using rule 38 (var -> name .)
    $end            reduce using rule 38 (var -> name .)
    UNTIL           reduce using rule 38 (var -> name .)
    ELSEIF          reduce using rule 38 (var -> name .)
    ELSE            reduce using rule 38 (var -> name .)
    END             reduce using rule 38 (var -> name .)
    ;               reduce using rule 38 (var -> name .)
    }               reduce using rule 38 (var -> name .)
    BREAK           reduce using rule 38 (var -> name .)
    RETURN          reduce using rule 38 (var -> name .)
    LOCAL           reduce using rule 38 (var -> name .)
    FUNCTION        reduce using rule 38 (var -> name .)
    FOR             reduce using rule 38 (var -> name .)
    IF              reduce using rule 38 (var -> name .)
    REPEAT          reduce using rule 38 (var -> name .)
    NAME            reduce using rule 38 (var -> name .)
    ]               reduce using rule 38 (var -> name .)
    DO              reduce using rule 38 (var -> name .)


state 7

    (12) stat -> FOR . namelist IN explist DO block END
    (13) stat -> FOR . name = exp , exp , exp DO block END
    (14) stat -> FOR . name = exp , exp DO block END
    (41) namelist -> . name
    (42) namelist -> . namelist , name
    (40) name -> . NAME
    NAME            shift and go to state 17

    namelist                       shift and go to state 31
    name                           shift and go to state 32

state 8

    (15) stat -> IF . exp THEN block elseiflist _else END
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 33
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 9

    (16) stat -> REPEAT . block UNTIL exp
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 50
    chunk                          shift and go to state 51
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 10

    (17) stat -> { . WHILE } exp { DO } block { END }
    (18) stat -> { . DO } block { END }
    WHILE           shift and go to state 52
    DO              shift and go to state 53


state 11

    (19) stat -> functioncall .
    (73) prefixexp -> functioncall .
  ! reduce/reduce conflict for ( resolved using rule 19 (stat -> functioncall .)
  ! reduce/reduce conflict for { resolved using rule 19 (stat -> functioncall .)
    ;               reduce using rule 19 (stat -> functioncall .)
    BREAK           reduce using rule 19 (stat -> functioncall .)
    RETURN          reduce using rule 19 (stat -> functioncall .)
    LOCAL           reduce using rule 19 (stat -> functioncall .)
    FUNCTION        reduce using rule 19 (stat -> functioncall .)
    FOR             reduce using rule 19 (stat -> functioncall .)
    IF              reduce using rule 19 (stat -> functioncall .)
    REPEAT          reduce using rule 19 (stat -> functioncall .)
    {               reduce using rule 19 (stat -> functioncall .)
    (               reduce using rule 19 (stat -> functioncall .)
    NAME            reduce using rule 19 (stat -> functioncall .)
    :               reduce using rule 73 (prefixexp -> functioncall .)
    .               reduce using rule 73 (prefixexp -> functioncall .)
    [               reduce using rule 73 (prefixexp -> functioncall .)
    STRING          reduce using rule 73 (prefixexp -> functioncall .)


state 12

    (20) stat -> location . = explist
    =               shift and go to state 54


state 13

    (75) functioncall -> prefixexp . : name args
    (76) functioncall -> prefixexp . args
    (36) var -> prefixexp . . name
    (37) var -> prefixexp . [ exp ]
    (77) args -> . STRING
    (78) args -> . tableconstructor
    (79) args -> . ( explist )
    (80) args -> . ( )
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    :               shift and go to state 55
    .               shift and go to state 57
    [               shift and go to state 58
    STRING          shift and go to state 59
    (               shift and go to state 61
    {               shift and go to state 46

    args                           shift and go to state 56
    tableconstructor               shift and go to state 60

state 14

    (39) location -> varlist .
    (35) varlist -> varlist . , var
    =               reduce using rule 39 (location -> varlist .)
    ,               shift and go to state 62


state 15

    (72) prefixexp -> ( . exp )
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 63
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 16

    (74) prefixexp -> var .
    (34) varlist -> var .
    :               reduce using rule 74 (prefixexp -> var .)
    .               reduce using rule 74 (prefixexp -> var .)
    [               reduce using rule 74 (prefixexp -> var .)
    STRING          reduce using rule 74 (prefixexp -> var .)
    (               reduce using rule 74 (prefixexp -> var .)
    {               reduce using rule 74 (prefixexp -> var .)
    ,               reduce using rule 34 (varlist -> var .)
    =               reduce using rule 34 (varlist -> var .)


state 17

    (40) name -> NAME .
    :               reduce using rule 40 (name -> NAME .)
    .               reduce using rule 40 (name -> NAME .)
    [               reduce using rule 40 (name -> NAME .)
    STRING          reduce using rule 40 (name -> NAME .)
    (               reduce using rule 40 (name -> NAME .)
    {               reduce using rule 40 (name -> NAME .)
    ,               reduce using rule 40 (name -> NAME .)
    =               reduce using rule 40 (name -> NAME .)
    ;               reduce using rule 40 (name -> NAME .)
    BREAK           reduce using rule 40 (name -> NAME .)
    RETURN          reduce using rule 40 (name -> NAME .)
    LOCAL           reduce using rule 40 (name -> NAME .)
    FUNCTION        reduce using rule 40 (name -> NAME .)
    FOR             reduce using rule 40 (name -> NAME .)
    IF              reduce using rule 40 (name -> NAME .)
    REPEAT          reduce using rule 40 (name -> NAME .)
    NAME            reduce using rule 40 (name -> NAME .)
    IN              reduce using rule 40 (name -> NAME .)
    THEN            reduce using rule 40 (name -> NAME .)
    OR              reduce using rule 40 (name -> NAME .)
    AND             reduce using rule 40 (name -> NAME .)
    NE              reduce using rule 40 (name -> NAME .)
    EQ              reduce using rule 40 (name -> NAME .)
    GE              reduce using rule 40 (name -> NAME .)
    GT              reduce using rule 40 (name -> NAME .)
    LE              reduce using rule 40 (name -> NAME .)
    LT              reduce using rule 40 (name -> NAME .)
    CONCAT          reduce using rule 40 (name -> NAME .)
    %               reduce using rule 40 (name -> NAME .)
    ^               reduce using rule 40 (name -> NAME .)
    /               reduce using rule 40 (name -> NAME .)
    *               reduce using rule 40 (name -> NAME .)
    -               reduce using rule 40 (name -> NAME .)
    +               reduce using rule 40 (name -> NAME .)
    )               reduce using rule 40 (name -> NAME .)
    $end            reduce using rule 40 (name -> NAME .)
    UNTIL           reduce using rule 40 (name -> NAME .)
    ELSEIF          reduce using rule 40 (name -> NAME .)
    ELSE            reduce using rule 40 (name -> NAME .)
    END             reduce using rule 40 (name -> NAME .)
    }               reduce using rule 40 (name -> NAME .)
    ]               reduce using rule 40 (name -> NAME .)
    DO              reduce using rule 40 (name -> NAME .)


state 18

    (1) chunk -> chunk2 laststat .
    $end            reduce using rule 1 (chunk -> chunk2 laststat .)
    UNTIL           reduce using rule 1 (chunk -> chunk2 laststat .)
    ELSEIF          reduce using rule 1 (chunk -> chunk2 laststat .)
    ELSE            reduce using rule 1 (chunk -> chunk2 laststat .)
    END             reduce using rule 1 (chunk -> chunk2 laststat .)
    {               reduce using rule 1 (chunk -> chunk2 laststat .)


state 19

    (2) chunk2 -> chunk2 stat . optsemi
    (5) optsemi -> . empty
    (6) optsemi -> . ;
    (100) empty -> .
    ;               shift and go to state 24
    BREAK           reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    LOCAL           reduce using rule 100 (empty -> .)
    FUNCTION        reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    REPEAT          reduce using rule 100 (empty -> .)
    {               reduce using rule 100 (empty -> .)
    (               reduce using rule 100 (empty -> .)
    NAME            reduce using rule 100 (empty -> .)

    optsemi                        shift and go to state 64
    empty                          shift and go to state 23

state 20

    (27) laststat -> BREAK . optsemi
    (5) optsemi -> . empty
    (6) optsemi -> . ;
    (100) empty -> .
    ;               shift and go to state 24
    $end            reduce using rule 100 (empty -> .)
    UNTIL           reduce using rule 100 (empty -> .)
    ELSEIF          reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    END             reduce using rule 100 (empty -> .)
    {               reduce using rule 100 (empty -> .)

    optsemi                        shift and go to state 65
    empty                          shift and go to state 23

state 21

    (28) laststat -> RETURN . explist
    (29) laststat -> RETURN . optsemi
    (43) explist -> . explist , exp
    (44) explist -> . exp
    (5) optsemi -> . empty
    (6) optsemi -> . ;
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (100) empty -> .
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
  ! shift/reduce conflict for { resolved as shift
    ;               shift and go to state 24
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    $end            reduce using rule 100 (empty -> .)
    UNTIL           reduce using rule 100 (empty -> .)
    ELSEIF          reduce using rule 100 (empty -> .)
    ELSE            reduce using rule 100 (empty -> .)
    END             reduce using rule 100 (empty -> .)
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    explist                        shift and go to state 66
    optsemi                        shift and go to state 67
    exp                            shift and go to state 68
    empty                          shift and go to state 23
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 22

    (3) chunk2 -> stat optsemi .
    BREAK           reduce using rule 3 (chunk2 -> stat optsemi .)
    RETURN          reduce using rule 3 (chunk2 -> stat optsemi .)
    LOCAL           reduce using rule 3 (chunk2 -> stat optsemi .)
    FUNCTION        reduce using rule 3 (chunk2 -> stat optsemi .)
    FOR             reduce using rule 3 (chunk2 -> stat optsemi .)
    IF              reduce using rule 3 (chunk2 -> stat optsemi .)
    REPEAT          reduce using rule 3 (chunk2 -> stat optsemi .)
    {               reduce using rule 3 (chunk2 -> stat optsemi .)
    (               reduce using rule 3 (chunk2 -> stat optsemi .)
    NAME            reduce using rule 3 (chunk2 -> stat optsemi .)


state 23

    (5) optsemi -> empty .
    BREAK           reduce using rule 5 (optsemi -> empty .)
    RETURN          reduce using rule 5 (optsemi -> empty .)
    LOCAL           reduce using rule 5 (optsemi -> empty .)
    FUNCTION        reduce using rule 5 (optsemi -> empty .)
    FOR             reduce using rule 5 (optsemi -> empty .)
    IF              reduce using rule 5 (optsemi -> empty .)
    REPEAT          reduce using rule 5 (optsemi -> empty .)
    {               reduce using rule 5 (optsemi -> empty .)
    (               reduce using rule 5 (optsemi -> empty .)
    NAME            reduce using rule 5 (optsemi -> empty .)
    $end            reduce using rule 5 (optsemi -> empty .)
    UNTIL           reduce using rule 5 (optsemi -> empty .)
    ELSEIF          reduce using rule 5 (optsemi -> empty .)
    ELSE            reduce using rule 5 (optsemi -> empty .)
    END             reduce using rule 5 (optsemi -> empty .)


state 24

    (6) optsemi -> ; .
    BREAK           reduce using rule 6 (optsemi -> ; .)
    RETURN          reduce using rule 6 (optsemi -> ; .)
    LOCAL           reduce using rule 6 (optsemi -> ; .)
    FUNCTION        reduce using rule 6 (optsemi -> ; .)
    FOR             reduce using rule 6 (optsemi -> ; .)
    IF              reduce using rule 6 (optsemi -> ; .)
    REPEAT          reduce using rule 6 (optsemi -> ; .)
    {               reduce using rule 6 (optsemi -> ; .)
    (               reduce using rule 6 (optsemi -> ; .)
    NAME            reduce using rule 6 (optsemi -> ; .)
    $end            reduce using rule 6 (optsemi -> ; .)
    UNTIL           reduce using rule 6 (optsemi -> ; .)
    ELSEIF          reduce using rule 6 (optsemi -> ; .)
    ELSE            reduce using rule 6 (optsemi -> ; .)
    END             reduce using rule 6 (optsemi -> ; .)


state 25

    (7) stat -> LOCAL namelist . = explist
    (8) stat -> LOCAL namelist .
    (42) namelist -> namelist . , name
    =               shift and go to state 69
    ;               reduce using rule 8 (stat -> LOCAL namelist .)
    BREAK           reduce using rule 8 (stat -> LOCAL namelist .)
    RETURN          reduce using rule 8 (stat -> LOCAL namelist .)
    LOCAL           reduce using rule 8 (stat -> LOCAL namelist .)
    FUNCTION        reduce using rule 8 (stat -> LOCAL namelist .)
    FOR             reduce using rule 8 (stat -> LOCAL namelist .)
    IF              reduce using rule 8 (stat -> LOCAL namelist .)
    REPEAT          reduce using rule 8 (stat -> LOCAL namelist .)
    {               reduce using rule 8 (stat -> LOCAL namelist .)
    (               reduce using rule 8 (stat -> LOCAL namelist .)
    NAME            reduce using rule 8 (stat -> LOCAL namelist .)
    ,               shift and go to state 70


state 26

    (9) stat -> LOCAL FUNCTION . name funcbody
    (40) name -> . NAME
    NAME            shift and go to state 17

    name                           shift and go to state 71

state 27

    (41) namelist -> name .
    =               reduce using rule 41 (namelist -> name .)
    ,               reduce using rule 41 (namelist -> name .)
    ;               reduce using rule 41 (namelist -> name .)
    BREAK           reduce using rule 41 (namelist -> name .)
    RETURN          reduce using rule 41 (namelist -> name .)
    LOCAL           reduce using rule 41 (namelist -> name .)
    FUNCTION        reduce using rule 41 (namelist -> name .)
    FOR             reduce using rule 41 (namelist -> name .)
    IF              reduce using rule 41 (namelist -> name .)
    REPEAT          reduce using rule 41 (namelist -> name .)
    {               reduce using rule 41 (namelist -> name .)
    (               reduce using rule 41 (namelist -> name .)
    NAME            reduce using rule 41 (namelist -> name .)
    )               reduce using rule 41 (namelist -> name .)


state 28

    (10) stat -> FUNCTION funcname . args
    (11) stat -> FUNCTION funcname . funcbody
    (77) args -> . STRING
    (78) args -> . tableconstructor
    (79) args -> . ( explist )
    (80) args -> . ( )
    (82) funcbody -> . ( ) block END
    (83) funcbody -> . ( parlist ) block END
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    STRING          shift and go to state 59
    (               shift and go to state 74
    {               shift and go to state 46

    args                           shift and go to state 72
    funcbody                       shift and go to state 73
    tableconstructor               shift and go to state 60

state 29

    (30) funcname -> funcname2 .
    (31) funcname -> funcname2 . : name
    (32) funcname2 -> funcname2 . . name
    STRING          reduce using rule 30 (funcname -> funcname2 .)
    (               reduce using rule 30 (funcname -> funcname2 .)
    {               reduce using rule 30 (funcname -> funcname2 .)
    :               shift and go to state 75
    .               shift and go to state 76


state 30

    (33) funcname2 -> name .
    :               reduce using rule 33 (funcname2 -> name .)
    .               reduce using rule 33 (funcname2 -> name .)
    STRING          reduce using rule 33 (funcname2 -> name .)
    (               reduce using rule 33 (funcname2 -> name .)
    {               reduce using rule 33 (funcname2 -> name .)


state 31

    (12) stat -> FOR namelist . IN explist DO block END
    (42) namelist -> namelist . , name
    IN              shift and go to state 77
    ,               shift and go to state 70


state 32

    (13) stat -> FOR name . = exp , exp , exp DO block END
    (14) stat -> FOR name . = exp , exp DO block END
    (41) namelist -> name .
    =               shift and go to state 78
    IN              reduce using rule 41 (namelist -> name .)
    ,               reduce using rule 41 (namelist -> name .)


state 33

    (15) stat -> IF exp . THEN block elseiflist _else END
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            shift and go to state 79
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 34

    (45) exp -> # . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 95
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 35

    (46) exp -> NOT . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 96
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 36

    (47) exp -> - . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 97
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 37

    (63) exp -> tableconstructor .
    THEN            reduce using rule 63 (exp -> tableconstructor .)
    OR              reduce using rule 63 (exp -> tableconstructor .)
    AND             reduce using rule 63 (exp -> tableconstructor .)
    NE              reduce using rule 63 (exp -> tableconstructor .)
    EQ              reduce using rule 63 (exp -> tableconstructor .)
    GE              reduce using rule 63 (exp -> tableconstructor .)
    GT              reduce using rule 63 (exp -> tableconstructor .)
    LE              reduce using rule 63 (exp -> tableconstructor .)
    LT              reduce using rule 63 (exp -> tableconstructor .)
    CONCAT          reduce using rule 63 (exp -> tableconstructor .)
    %               reduce using rule 63 (exp -> tableconstructor .)
    ^               reduce using rule 63 (exp -> tableconstructor .)
    /               reduce using rule 63 (exp -> tableconstructor .)
    *               reduce using rule 63 (exp -> tableconstructor .)
    -               reduce using rule 63 (exp -> tableconstructor .)
    +               reduce using rule 63 (exp -> tableconstructor .)
    )               reduce using rule 63 (exp -> tableconstructor .)
    ,               reduce using rule 63 (exp -> tableconstructor .)
    $end            reduce using rule 63 (exp -> tableconstructor .)
    UNTIL           reduce using rule 63 (exp -> tableconstructor .)
    ELSEIF          reduce using rule 63 (exp -> tableconstructor .)
    ELSE            reduce using rule 63 (exp -> tableconstructor .)
    END             reduce using rule 63 (exp -> tableconstructor .)
    {               reduce using rule 63 (exp -> tableconstructor .)
    ;               reduce using rule 63 (exp -> tableconstructor .)
    }               reduce using rule 63 (exp -> tableconstructor .)
    BREAK           reduce using rule 63 (exp -> tableconstructor .)
    RETURN          reduce using rule 63 (exp -> tableconstructor .)
    LOCAL           reduce using rule 63 (exp -> tableconstructor .)
    FUNCTION        reduce using rule 63 (exp -> tableconstructor .)
    FOR             reduce using rule 63 (exp -> tableconstructor .)
    IF              reduce using rule 63 (exp -> tableconstructor .)
    REPEAT          reduce using rule 63 (exp -> tableconstructor .)
    (               reduce using rule 63 (exp -> tableconstructor .)
    NAME            reduce using rule 63 (exp -> tableconstructor .)
    ]               reduce using rule 63 (exp -> tableconstructor .)
    DO              reduce using rule 63 (exp -> tableconstructor .)


state 38

    (64) exp -> prefixexp .
    (75) functioncall -> prefixexp . : name args
    (76) functioncall -> prefixexp . args
    (36) var -> prefixexp . . name
    (37) var -> prefixexp . [ exp ]
    (77) args -> . STRING
    (78) args -> . tableconstructor
    (79) args -> . ( explist )
    (80) args -> . ( )
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for { resolved as shift
    THEN            reduce using rule 64 (exp -> prefixexp .)
    OR              reduce using rule 64 (exp -> prefixexp .)
    AND             reduce using rule 64 (exp -> prefixexp .)
    NE              reduce using rule 64 (exp -> prefixexp .)
    EQ              reduce using rule 64 (exp -> prefixexp .)
    GE              reduce using rule 64 (exp -> prefixexp .)
    GT              reduce using rule 64 (exp -> prefixexp .)
    LE              reduce using rule 64 (exp -> prefixexp .)
    LT              reduce using rule 64 (exp -> prefixexp .)
    CONCAT          reduce using rule 64 (exp -> prefixexp .)
    %               reduce using rule 64 (exp -> prefixexp .)
    ^               reduce using rule 64 (exp -> prefixexp .)
    /               reduce using rule 64 (exp -> prefixexp .)
    *               reduce using rule 64 (exp -> prefixexp .)
    -               reduce using rule 64 (exp -> prefixexp .)
    +               reduce using rule 64 (exp -> prefixexp .)
    )               reduce using rule 64 (exp -> prefixexp .)
    ,               reduce using rule 64 (exp -> prefixexp .)
    $end            reduce using rule 64 (exp -> prefixexp .)
    UNTIL           reduce using rule 64 (exp -> prefixexp .)
    ELSEIF          reduce using rule 64 (exp -> prefixexp .)
    ELSE            reduce using rule 64 (exp -> prefixexp .)
    END             reduce using rule 64 (exp -> prefixexp .)
    ;               reduce using rule 64 (exp -> prefixexp .)
    }               reduce using rule 64 (exp -> prefixexp .)
    BREAK           reduce using rule 64 (exp -> prefixexp .)
    RETURN          reduce using rule 64 (exp -> prefixexp .)
    LOCAL           reduce using rule 64 (exp -> prefixexp .)
    FUNCTION        reduce using rule 64 (exp -> prefixexp .)
    FOR             reduce using rule 64 (exp -> prefixexp .)
    IF              reduce using rule 64 (exp -> prefixexp .)
    REPEAT          reduce using rule 64 (exp -> prefixexp .)
    NAME            reduce using rule 64 (exp -> prefixexp .)
    ]               reduce using rule 64 (exp -> prefixexp .)
    DO              reduce using rule 64 (exp -> prefixexp .)
    :               shift and go to state 55
    .               shift and go to state 57
    [               shift and go to state 58
    STRING          shift and go to state 59
    (               shift and go to state 61
    {               shift and go to state 46

    args                           shift and go to state 56
    tableconstructor               shift and go to state 60

state 39

    (65) exp -> function .
    THEN            reduce using rule 65 (exp -> function .)
    OR              reduce using rule 65 (exp -> function .)
    AND             reduce using rule 65 (exp -> function .)
    NE              reduce using rule 65 (exp -> function .)
    EQ              reduce using rule 65 (exp -> function .)
    GE              reduce using rule 65 (exp -> function .)
    GT              reduce using rule 65 (exp -> function .)
    LE              reduce using rule 65 (exp -> function .)
    LT              reduce using rule 65 (exp -> function .)
    CONCAT          reduce using rule 65 (exp -> function .)
    %               reduce using rule 65 (exp -> function .)
    ^               reduce using rule 65 (exp -> function .)
    /               reduce using rule 65 (exp -> function .)
    *               reduce using rule 65 (exp -> function .)
    -               reduce using rule 65 (exp -> function .)
    +               reduce using rule 65 (exp -> function .)
    )               reduce using rule 65 (exp -> function .)
    ,               reduce using rule 65 (exp -> function .)
    $end            reduce using rule 65 (exp -> function .)
    UNTIL           reduce using rule 65 (exp -> function .)
    ELSEIF          reduce using rule 65 (exp -> function .)
    ELSE            reduce using rule 65 (exp -> function .)
    END             reduce using rule 65 (exp -> function .)
    {               reduce using rule 65 (exp -> function .)
    ;               reduce using rule 65 (exp -> function .)
    }               reduce using rule 65 (exp -> function .)
    BREAK           reduce using rule 65 (exp -> function .)
    RETURN          reduce using rule 65 (exp -> function .)
    LOCAL           reduce using rule 65 (exp -> function .)
    FUNCTION        reduce using rule 65 (exp -> function .)
    FOR             reduce using rule 65 (exp -> function .)
    IF              reduce using rule 65 (exp -> function .)
    REPEAT          reduce using rule 65 (exp -> function .)
    (               reduce using rule 65 (exp -> function .)
    NAME            reduce using rule 65 (exp -> function .)
    ]               reduce using rule 65 (exp -> function .)
    DO              reduce using rule 65 (exp -> function .)


state 40

    (66) exp -> VARARG .
    THEN            reduce using rule 66 (exp -> VARARG .)
    OR              reduce using rule 66 (exp -> VARARG .)
    AND             reduce using rule 66 (exp -> VARARG .)
    NE              reduce using rule 66 (exp -> VARARG .)
    EQ              reduce using rule 66 (exp -> VARARG .)
    GE              reduce using rule 66 (exp -> VARARG .)
    GT              reduce using rule 66 (exp -> VARARG .)
    LE              reduce using rule 66 (exp -> VARARG .)
    LT              reduce using rule 66 (exp -> VARARG .)
    CONCAT          reduce using rule 66 (exp -> VARARG .)
    %               reduce using rule 66 (exp -> VARARG .)
    ^               reduce using rule 66 (exp -> VARARG .)
    /               reduce using rule 66 (exp -> VARARG .)
    *               reduce using rule 66 (exp -> VARARG .)
    -               reduce using rule 66 (exp -> VARARG .)
    +               reduce using rule 66 (exp -> VARARG .)
    )               reduce using rule 66 (exp -> VARARG .)
    ,               reduce using rule 66 (exp -> VARARG .)
    $end            reduce using rule 66 (exp -> VARARG .)
    UNTIL           reduce using rule 66 (exp -> VARARG .)
    ELSEIF          reduce using rule 66 (exp -> VARARG .)
    ELSE            reduce using rule 66 (exp -> VARARG .)
    END             reduce using rule 66 (exp -> VARARG .)
    {               reduce using rule 66 (exp -> VARARG .)
    ;               reduce using rule 66 (exp -> VARARG .)
    }               reduce using rule 66 (exp -> VARARG .)
    BREAK           reduce using rule 66 (exp -> VARARG .)
    RETURN          reduce using rule 66 (exp -> VARARG .)
    LOCAL           reduce using rule 66 (exp -> VARARG .)
    FUNCTION        reduce using rule 66 (exp -> VARARG .)
    FOR             reduce using rule 66 (exp -> VARARG .)
    IF              reduce using rule 66 (exp -> VARARG .)
    REPEAT          reduce using rule 66 (exp -> VARARG .)
    (               reduce using rule 66 (exp -> VARARG .)
    NAME            reduce using rule 66 (exp -> VARARG .)
    ]               reduce using rule 66 (exp -> VARARG .)
    DO              reduce using rule 66 (exp -> VARARG .)


state 41

    (67) exp -> NIL .
    THEN            reduce using rule 67 (exp -> NIL .)
    OR              reduce using rule 67 (exp -> NIL .)
    AND             reduce using rule 67 (exp -> NIL .)
    NE              reduce using rule 67 (exp -> NIL .)
    EQ              reduce using rule 67 (exp -> NIL .)
    GE              reduce using rule 67 (exp -> NIL .)
    GT              reduce using rule 67 (exp -> NIL .)
    LE              reduce using rule 67 (exp -> NIL .)
    LT              reduce using rule 67 (exp -> NIL .)
    CONCAT          reduce using rule 67 (exp -> NIL .)
    %               reduce using rule 67 (exp -> NIL .)
    ^               reduce using rule 67 (exp -> NIL .)
    /               reduce using rule 67 (exp -> NIL .)
    *               reduce using rule 67 (exp -> NIL .)
    -               reduce using rule 67 (exp -> NIL .)
    +               reduce using rule 67 (exp -> NIL .)
    )               reduce using rule 67 (exp -> NIL .)
    ,               reduce using rule 67 (exp -> NIL .)
    $end            reduce using rule 67 (exp -> NIL .)
    UNTIL           reduce using rule 67 (exp -> NIL .)
    ELSEIF          reduce using rule 67 (exp -> NIL .)
    ELSE            reduce using rule 67 (exp -> NIL .)
    END             reduce using rule 67 (exp -> NIL .)
    {               reduce using rule 67 (exp -> NIL .)
    ;               reduce using rule 67 (exp -> NIL .)
    }               reduce using rule 67 (exp -> NIL .)
    BREAK           reduce using rule 67 (exp -> NIL .)
    RETURN          reduce using rule 67 (exp -> NIL .)
    LOCAL           reduce using rule 67 (exp -> NIL .)
    FUNCTION        reduce using rule 67 (exp -> NIL .)
    FOR             reduce using rule 67 (exp -> NIL .)
    IF              reduce using rule 67 (exp -> NIL .)
    REPEAT          reduce using rule 67 (exp -> NIL .)
    (               reduce using rule 67 (exp -> NIL .)
    NAME            reduce using rule 67 (exp -> NIL .)
    ]               reduce using rule 67 (exp -> NIL .)
    DO              reduce using rule 67 (exp -> NIL .)


state 42

    (68) exp -> NUMBER .
    THEN            reduce using rule 68 (exp -> NUMBER .)
    OR              reduce using rule 68 (exp -> NUMBER .)
    AND             reduce using rule 68 (exp -> NUMBER .)
    NE              reduce using rule 68 (exp -> NUMBER .)
    EQ              reduce using rule 68 (exp -> NUMBER .)
    GE              reduce using rule 68 (exp -> NUMBER .)
    GT              reduce using rule 68 (exp -> NUMBER .)
    LE              reduce using rule 68 (exp -> NUMBER .)
    LT              reduce using rule 68 (exp -> NUMBER .)
    CONCAT          reduce using rule 68 (exp -> NUMBER .)
    %               reduce using rule 68 (exp -> NUMBER .)
    ^               reduce using rule 68 (exp -> NUMBER .)
    /               reduce using rule 68 (exp -> NUMBER .)
    *               reduce using rule 68 (exp -> NUMBER .)
    -               reduce using rule 68 (exp -> NUMBER .)
    +               reduce using rule 68 (exp -> NUMBER .)
    )               reduce using rule 68 (exp -> NUMBER .)
    ,               reduce using rule 68 (exp -> NUMBER .)
    $end            reduce using rule 68 (exp -> NUMBER .)
    UNTIL           reduce using rule 68 (exp -> NUMBER .)
    ELSEIF          reduce using rule 68 (exp -> NUMBER .)
    ELSE            reduce using rule 68 (exp -> NUMBER .)
    END             reduce using rule 68 (exp -> NUMBER .)
    {               reduce using rule 68 (exp -> NUMBER .)
    ;               reduce using rule 68 (exp -> NUMBER .)
    }               reduce using rule 68 (exp -> NUMBER .)
    BREAK           reduce using rule 68 (exp -> NUMBER .)
    RETURN          reduce using rule 68 (exp -> NUMBER .)
    LOCAL           reduce using rule 68 (exp -> NUMBER .)
    FUNCTION        reduce using rule 68 (exp -> NUMBER .)
    FOR             reduce using rule 68 (exp -> NUMBER .)
    IF              reduce using rule 68 (exp -> NUMBER .)
    REPEAT          reduce using rule 68 (exp -> NUMBER .)
    (               reduce using rule 68 (exp -> NUMBER .)
    NAME            reduce using rule 68 (exp -> NUMBER .)
    ]               reduce using rule 68 (exp -> NUMBER .)
    DO              reduce using rule 68 (exp -> NUMBER .)


state 43

    (69) exp -> STRING .
    THEN            reduce using rule 69 (exp -> STRING .)
    OR              reduce using rule 69 (exp -> STRING .)
    AND             reduce using rule 69 (exp -> STRING .)
    NE              reduce using rule 69 (exp -> STRING .)
    EQ              reduce using rule 69 (exp -> STRING .)
    GE              reduce using rule 69 (exp -> STRING .)
    GT              reduce using rule 69 (exp -> STRING .)
    LE              reduce using rule 69 (exp -> STRING .)
    LT              reduce using rule 69 (exp -> STRING .)
    CONCAT          reduce using rule 69 (exp -> STRING .)
    %               reduce using rule 69 (exp -> STRING .)
    ^               reduce using rule 69 (exp -> STRING .)
    /               reduce using rule 69 (exp -> STRING .)
    *               reduce using rule 69 (exp -> STRING .)
    -               reduce using rule 69 (exp -> STRING .)
    +               reduce using rule 69 (exp -> STRING .)
    )               reduce using rule 69 (exp -> STRING .)
    ,               reduce using rule 69 (exp -> STRING .)
    $end            reduce using rule 69 (exp -> STRING .)
    UNTIL           reduce using rule 69 (exp -> STRING .)
    ELSEIF          reduce using rule 69 (exp -> STRING .)
    ELSE            reduce using rule 69 (exp -> STRING .)
    END             reduce using rule 69 (exp -> STRING .)
    {               reduce using rule 69 (exp -> STRING .)
    ;               reduce using rule 69 (exp -> STRING .)
    }               reduce using rule 69 (exp -> STRING .)
    BREAK           reduce using rule 69 (exp -> STRING .)
    RETURN          reduce using rule 69 (exp -> STRING .)
    LOCAL           reduce using rule 69 (exp -> STRING .)
    FUNCTION        reduce using rule 69 (exp -> STRING .)
    FOR             reduce using rule 69 (exp -> STRING .)
    IF              reduce using rule 69 (exp -> STRING .)
    REPEAT          reduce using rule 69 (exp -> STRING .)
    (               reduce using rule 69 (exp -> STRING .)
    NAME            reduce using rule 69 (exp -> STRING .)
    ]               reduce using rule 69 (exp -> STRING .)
    DO              reduce using rule 69 (exp -> STRING .)


state 44

    (70) exp -> TRUE .
    THEN            reduce using rule 70 (exp -> TRUE .)
    OR              reduce using rule 70 (exp -> TRUE .)
    AND             reduce using rule 70 (exp -> TRUE .)
    NE              reduce using rule 70 (exp -> TRUE .)
    EQ              reduce using rule 70 (exp -> TRUE .)
    GE              reduce using rule 70 (exp -> TRUE .)
    GT              reduce using rule 70 (exp -> TRUE .)
    LE              reduce using rule 70 (exp -> TRUE .)
    LT              reduce using rule 70 (exp -> TRUE .)
    CONCAT          reduce using rule 70 (exp -> TRUE .)
    %               reduce using rule 70 (exp -> TRUE .)
    ^               reduce using rule 70 (exp -> TRUE .)
    /               reduce using rule 70 (exp -> TRUE .)
    *               reduce using rule 70 (exp -> TRUE .)
    -               reduce using rule 70 (exp -> TRUE .)
    +               reduce using rule 70 (exp -> TRUE .)
    )               reduce using rule 70 (exp -> TRUE .)
    ,               reduce using rule 70 (exp -> TRUE .)
    $end            reduce using rule 70 (exp -> TRUE .)
    UNTIL           reduce using rule 70 (exp -> TRUE .)
    ELSEIF          reduce using rule 70 (exp -> TRUE .)
    ELSE            reduce using rule 70 (exp -> TRUE .)
    END             reduce using rule 70 (exp -> TRUE .)
    {               reduce using rule 70 (exp -> TRUE .)
    ;               reduce using rule 70 (exp -> TRUE .)
    }               reduce using rule 70 (exp -> TRUE .)
    BREAK           reduce using rule 70 (exp -> TRUE .)
    RETURN          reduce using rule 70 (exp -> TRUE .)
    LOCAL           reduce using rule 70 (exp -> TRUE .)
    FUNCTION        reduce using rule 70 (exp -> TRUE .)
    FOR             reduce using rule 70 (exp -> TRUE .)
    IF              reduce using rule 70 (exp -> TRUE .)
    REPEAT          reduce using rule 70 (exp -> TRUE .)
    (               reduce using rule 70 (exp -> TRUE .)
    NAME            reduce using rule 70 (exp -> TRUE .)
    ]               reduce using rule 70 (exp -> TRUE .)
    DO              reduce using rule 70 (exp -> TRUE .)


state 45

    (71) exp -> FALSE .
    THEN            reduce using rule 71 (exp -> FALSE .)
    OR              reduce using rule 71 (exp -> FALSE .)
    AND             reduce using rule 71 (exp -> FALSE .)
    NE              reduce using rule 71 (exp -> FALSE .)
    EQ              reduce using rule 71 (exp -> FALSE .)
    GE              reduce using rule 71 (exp -> FALSE .)
    GT              reduce using rule 71 (exp -> FALSE .)
    LE              reduce using rule 71 (exp -> FALSE .)
    LT              reduce using rule 71 (exp -> FALSE .)
    CONCAT          reduce using rule 71 (exp -> FALSE .)
    %               reduce using rule 71 (exp -> FALSE .)
    ^               reduce using rule 71 (exp -> FALSE .)
    /               reduce using rule 71 (exp -> FALSE .)
    *               reduce using rule 71 (exp -> FALSE .)
    -               reduce using rule 71 (exp -> FALSE .)
    +               reduce using rule 71 (exp -> FALSE .)
    )               reduce using rule 71 (exp -> FALSE .)
    ,               reduce using rule 71 (exp -> FALSE .)
    $end            reduce using rule 71 (exp -> FALSE .)
    UNTIL           reduce using rule 71 (exp -> FALSE .)
    ELSEIF          reduce using rule 71 (exp -> FALSE .)
    ELSE            reduce using rule 71 (exp -> FALSE .)
    END             reduce using rule 71 (exp -> FALSE .)
    {               reduce using rule 71 (exp -> FALSE .)
    ;               reduce using rule 71 (exp -> FALSE .)
    }               reduce using rule 71 (exp -> FALSE .)
    BREAK           reduce using rule 71 (exp -> FALSE .)
    RETURN          reduce using rule 71 (exp -> FALSE .)
    LOCAL           reduce using rule 71 (exp -> FALSE .)
    FUNCTION        reduce using rule 71 (exp -> FALSE .)
    FOR             reduce using rule 71 (exp -> FALSE .)
    IF              reduce using rule 71 (exp -> FALSE .)
    REPEAT          reduce using rule 71 (exp -> FALSE .)
    (               reduce using rule 71 (exp -> FALSE .)
    NAME            reduce using rule 71 (exp -> FALSE .)
    ]               reduce using rule 71 (exp -> FALSE .)
    DO              reduce using rule 71 (exp -> FALSE .)


state 46

    (88) tableconstructor -> { . }
    (89) tableconstructor -> { . fieldlist }
    (90) fieldlist -> . fieldlist2 optfieldsep
    (91) fieldlist2 -> . fieldlist2 fieldsep field
    (92) fieldlist2 -> . field
    (93) field -> . exp
    (94) field -> . NAME = exp
    (95) field -> . [ exp ] = exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    }               shift and go to state 98
    NAME            shift and go to state 103
    [               shift and go to state 104
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49

    fieldlist                      shift and go to state 99
    fieldlist2                     shift and go to state 100
    field                          shift and go to state 101
    exp                            shift and go to state 102
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 47

    (73) prefixexp -> functioncall .
    :               reduce using rule 73 (prefixexp -> functioncall .)
    .               reduce using rule 73 (prefixexp -> functioncall .)
    [               reduce using rule 73 (prefixexp -> functioncall .)
    STRING          reduce using rule 73 (prefixexp -> functioncall .)
    (               reduce using rule 73 (prefixexp -> functioncall .)
    {               reduce using rule 73 (prefixexp -> functioncall .)
    THEN            reduce using rule 73 (prefixexp -> functioncall .)
    OR              reduce using rule 73 (prefixexp -> functioncall .)
    AND             reduce using rule 73 (prefixexp -> functioncall .)
    NE              reduce using rule 73 (prefixexp -> functioncall .)
    EQ              reduce using rule 73 (prefixexp -> functioncall .)
    GE              reduce using rule 73 (prefixexp -> functioncall .)
    GT              reduce using rule 73 (prefixexp -> functioncall .)
    LE              reduce using rule 73 (prefixexp -> functioncall .)
    LT              reduce using rule 73 (prefixexp -> functioncall .)
    CONCAT          reduce using rule 73 (prefixexp -> functioncall .)
    %               reduce using rule 73 (prefixexp -> functioncall .)
    ^               reduce using rule 73 (prefixexp -> functioncall .)
    /               reduce using rule 73 (prefixexp -> functioncall .)
    *               reduce using rule 73 (prefixexp -> functioncall .)
    -               reduce using rule 73 (prefixexp -> functioncall .)
    +               reduce using rule 73 (prefixexp -> functioncall .)
    )               reduce using rule 73 (prefixexp -> functioncall .)
    ,               reduce using rule 73 (prefixexp -> functioncall .)
    $end            reduce using rule 73 (prefixexp -> functioncall .)
    UNTIL           reduce using rule 73 (prefixexp -> functioncall .)
    ELSEIF          reduce using rule 73 (prefixexp -> functioncall .)
    ELSE            reduce using rule 73 (prefixexp -> functioncall .)
    END             reduce using rule 73 (prefixexp -> functioncall .)
    ;               reduce using rule 73 (prefixexp -> functioncall .)
    }               reduce using rule 73 (prefixexp -> functioncall .)
    BREAK           reduce using rule 73 (prefixexp -> functioncall .)
    RETURN          reduce using rule 73 (prefixexp -> functioncall .)
    LOCAL           reduce using rule 73 (prefixexp -> functioncall .)
    FUNCTION        reduce using rule 73 (prefixexp -> functioncall .)
    FOR             reduce using rule 73 (prefixexp -> functioncall .)
    IF              reduce using rule 73 (prefixexp -> functioncall .)
    REPEAT          reduce using rule 73 (prefixexp -> functioncall .)
    NAME            reduce using rule 73 (prefixexp -> functioncall .)
    ]               reduce using rule 73 (prefixexp -> functioncall .)
    DO              reduce using rule 73 (prefixexp -> functioncall .)


state 48

    (74) prefixexp -> var .
    :               reduce using rule 74 (prefixexp -> var .)
    .               reduce using rule 74 (prefixexp -> var .)
    [               reduce using rule 74 (prefixexp -> var .)
    STRING          reduce using rule 74 (prefixexp -> var .)
    (               reduce using rule 74 (prefixexp -> var .)
    {               reduce using rule 74 (prefixexp -> var .)
    THEN            reduce using rule 74 (prefixexp -> var .)
    OR              reduce using rule 74 (prefixexp -> var .)
    AND             reduce using rule 74 (prefixexp -> var .)
    NE              reduce using rule 74 (prefixexp -> var .)
    EQ              reduce using rule 74 (prefixexp -> var .)
    GE              reduce using rule 74 (prefixexp -> var .)
    GT              reduce using rule 74 (prefixexp -> var .)
    LE              reduce using rule 74 (prefixexp -> var .)
    LT              reduce using rule 74 (prefixexp -> var .)
    CONCAT          reduce using rule 74 (prefixexp -> var .)
    %               reduce using rule 74 (prefixexp -> var .)
    ^               reduce using rule 74 (prefixexp -> var .)
    /               reduce using rule 74 (prefixexp -> var .)
    *               reduce using rule 74 (prefixexp -> var .)
    -               reduce using rule 74 (prefixexp -> var .)
    +               reduce using rule 74 (prefixexp -> var .)
    )               reduce using rule 74 (prefixexp -> var .)
    ,               reduce using rule 74 (prefixexp -> var .)
    $end            reduce using rule 74 (prefixexp -> var .)
    UNTIL           reduce using rule 74 (prefixexp -> var .)
    ELSEIF          reduce using rule 74 (prefixexp -> var .)
    ELSE            reduce using rule 74 (prefixexp -> var .)
    END             reduce using rule 74 (prefixexp -> var .)
    ;               reduce using rule 74 (prefixexp -> var .)
    }               reduce using rule 74 (prefixexp -> var .)
    BREAK           reduce using rule 74 (prefixexp -> var .)
    RETURN          reduce using rule 74 (prefixexp -> var .)
    LOCAL           reduce using rule 74 (prefixexp -> var .)
    FUNCTION        reduce using rule 74 (prefixexp -> var .)
    FOR             reduce using rule 74 (prefixexp -> var .)
    IF              reduce using rule 74 (prefixexp -> var .)
    REPEAT          reduce using rule 74 (prefixexp -> var .)
    NAME            reduce using rule 74 (prefixexp -> var .)
    ]               reduce using rule 74 (prefixexp -> var .)
    DO              reduce using rule 74 (prefixexp -> var .)


state 49

    (81) function -> FUNCTION . funcbody
    (82) funcbody -> . ( ) block END
    (83) funcbody -> . ( parlist ) block END
    (               shift and go to state 106

    funcbody                       shift and go to state 105

state 50

    (16) stat -> REPEAT block . UNTIL exp
    UNTIL           shift and go to state 107


state 51

    (4) block -> chunk .
    UNTIL           reduce using rule 4 (block -> chunk .)
    ELSEIF          reduce using rule 4 (block -> chunk .)
    ELSE            reduce using rule 4 (block -> chunk .)
    END             reduce using rule 4 (block -> chunk .)
    {               reduce using rule 4 (block -> chunk .)


state 52

    (17) stat -> { WHILE . } exp { DO } block { END }
    }               shift and go to state 108


state 53

    (18) stat -> { DO . } block { END }
    }               shift and go to state 109


state 54

    (20) stat -> location = . explist
    (43) explist -> . explist , exp
    (44) explist -> . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    explist                        shift and go to state 110
    exp                            shift and go to state 68
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 55

    (75) functioncall -> prefixexp : . name args
    (40) name -> . NAME
    NAME            shift and go to state 17

    name                           shift and go to state 111

state 56

    (76) functioncall -> prefixexp args .
    ;               reduce using rule 76 (functioncall -> prefixexp args .)
    BREAK           reduce using rule 76 (functioncall -> prefixexp args .)
    RETURN          reduce using rule 76 (functioncall -> prefixexp args .)
    LOCAL           reduce using rule 76 (functioncall -> prefixexp args .)
    FUNCTION        reduce using rule 76 (functioncall -> prefixexp args .)
    FOR             reduce using rule 76 (functioncall -> prefixexp args .)
    IF              reduce using rule 76 (functioncall -> prefixexp args .)
    REPEAT          reduce using rule 76 (functioncall -> prefixexp args .)
    {               reduce using rule 76 (functioncall -> prefixexp args .)
    (               reduce using rule 76 (functioncall -> prefixexp args .)
    NAME            reduce using rule 76 (functioncall -> prefixexp args .)
    :               reduce using rule 76 (functioncall -> prefixexp args .)
    .               reduce using rule 76 (functioncall -> prefixexp args .)
    [               reduce using rule 76 (functioncall -> prefixexp args .)
    STRING          reduce using rule 76 (functioncall -> prefixexp args .)
    THEN            reduce using rule 76 (functioncall -> prefixexp args .)
    OR              reduce using rule 76 (functioncall -> prefixexp args .)
    AND             reduce using rule 76 (functioncall -> prefixexp args .)
    NE              reduce using rule 76 (functioncall -> prefixexp args .)
    EQ              reduce using rule 76 (functioncall -> prefixexp args .)
    GE              reduce using rule 76 (functioncall -> prefixexp args .)
    GT              reduce using rule 76 (functioncall -> prefixexp args .)
    LE              reduce using rule 76 (functioncall -> prefixexp args .)
    LT              reduce using rule 76 (functioncall -> prefixexp args .)
    CONCAT          reduce using rule 76 (functioncall -> prefixexp args .)
    %               reduce using rule 76 (functioncall -> prefixexp args .)
    ^               reduce using rule 76 (functioncall -> prefixexp args .)
    /               reduce using rule 76 (functioncall -> prefixexp args .)
    *               reduce using rule 76 (functioncall -> prefixexp args .)
    -               reduce using rule 76 (functioncall -> prefixexp args .)
    +               reduce using rule 76 (functioncall -> prefixexp args .)
    )               reduce using rule 76 (functioncall -> prefixexp args .)
    ,               reduce using rule 76 (functioncall -> prefixexp args .)
    $end            reduce using rule 76 (functioncall -> prefixexp args .)
    UNTIL           reduce using rule 76 (functioncall -> prefixexp args .)
    ELSEIF          reduce using rule 76 (functioncall -> prefixexp args .)
    ELSE            reduce using rule 76 (functioncall -> prefixexp args .)
    END             reduce using rule 76 (functioncall -> prefixexp args .)
    }               reduce using rule 76 (functioncall -> prefixexp args .)
    ]               reduce using rule 76 (functioncall -> prefixexp args .)
    DO              reduce using rule 76 (functioncall -> prefixexp args .)


state 57

    (36) var -> prefixexp . . name
    (40) name -> . NAME
    NAME            shift and go to state 17

    name                           shift and go to state 112

state 58

    (37) var -> prefixexp [ . exp ]
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    prefixexp                      shift and go to state 38
    exp                            shift and go to state 113
    tableconstructor               shift and go to state 37
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 59

    (77) args -> STRING .
    ;               reduce using rule 77 (args -> STRING .)
    BREAK           reduce using rule 77 (args -> STRING .)
    RETURN          reduce using rule 77 (args -> STRING .)
    LOCAL           reduce using rule 77 (args -> STRING .)
    FUNCTION        reduce using rule 77 (args -> STRING .)
    FOR             reduce using rule 77 (args -> STRING .)
    IF              reduce using rule 77 (args -> STRING .)
    REPEAT          reduce using rule 77 (args -> STRING .)
    {               reduce using rule 77 (args -> STRING .)
    (               reduce using rule 77 (args -> STRING .)
    NAME            reduce using rule 77 (args -> STRING .)
    :               reduce using rule 77 (args -> STRING .)
    .               reduce using rule 77 (args -> STRING .)
    [               reduce using rule 77 (args -> STRING .)
    STRING          reduce using rule 77 (args -> STRING .)
    THEN            reduce using rule 77 (args -> STRING .)
    OR              reduce using rule 77 (args -> STRING .)
    AND             reduce using rule 77 (args -> STRING .)
    NE              reduce using rule 77 (args -> STRING .)
    EQ              reduce using rule 77 (args -> STRING .)
    GE              reduce using rule 77 (args -> STRING .)
    GT              reduce using rule 77 (args -> STRING .)
    LE              reduce using rule 77 (args -> STRING .)
    LT              reduce using rule 77 (args -> STRING .)
    CONCAT          reduce using rule 77 (args -> STRING .)
    %               reduce using rule 77 (args -> STRING .)
    ^               reduce using rule 77 (args -> STRING .)
    /               reduce using rule 77 (args -> STRING .)
    *               reduce using rule 77 (args -> STRING .)
    -               reduce using rule 77 (args -> STRING .)
    +               reduce using rule 77 (args -> STRING .)
    )               reduce using rule 77 (args -> STRING .)
    ,               reduce using rule 77 (args -> STRING .)
    $end            reduce using rule 77 (args -> STRING .)
    UNTIL           reduce using rule 77 (args -> STRING .)
    ELSEIF          reduce using rule 77 (args -> STRING .)
    ELSE            reduce using rule 77 (args -> STRING .)
    END             reduce using rule 77 (args -> STRING .)
    }               reduce using rule 77 (args -> STRING .)
    ]               reduce using rule 77 (args -> STRING .)
    DO              reduce using rule 77 (args -> STRING .)


state 60

    (78) args -> tableconstructor .
    ;               reduce using rule 78 (args -> tableconstructor .)
    BREAK           reduce using rule 78 (args -> tableconstructor .)
    RETURN          reduce using rule 78 (args -> tableconstructor .)
    LOCAL           reduce using rule 78 (args -> tableconstructor .)
    FUNCTION        reduce using rule 78 (args -> tableconstructor .)
    FOR             reduce using rule 78 (args -> tableconstructor .)
    IF              reduce using rule 78 (args -> tableconstructor .)
    REPEAT          reduce using rule 78 (args -> tableconstructor .)
    {               reduce using rule 78 (args -> tableconstructor .)
    (               reduce using rule 78 (args -> tableconstructor .)
    NAME            reduce using rule 78 (args -> tableconstructor .)
    :               reduce using rule 78 (args -> tableconstructor .)
    .               reduce using rule 78 (args -> tableconstructor .)
    [               reduce using rule 78 (args -> tableconstructor .)
    STRING          reduce using rule 78 (args -> tableconstructor .)
    THEN            reduce using rule 78 (args -> tableconstructor .)
    OR              reduce using rule 78 (args -> tableconstructor .)
    AND             reduce using rule 78 (args -> tableconstructor .)
    NE              reduce using rule 78 (args -> tableconstructor .)
    EQ              reduce using rule 78 (args -> tableconstructor .)
    GE              reduce using rule 78 (args -> tableconstructor .)
    GT              reduce using rule 78 (args -> tableconstructor .)
    LE              reduce using rule 78 (args -> tableconstructor .)
    LT              reduce using rule 78 (args -> tableconstructor .)
    CONCAT          reduce using rule 78 (args -> tableconstructor .)
    %               reduce using rule 78 (args -> tableconstructor .)
    ^               reduce using rule 78 (args -> tableconstructor .)
    /               reduce using rule 78 (args -> tableconstructor .)
    *               reduce using rule 78 (args -> tableconstructor .)
    -               reduce using rule 78 (args -> tableconstructor .)
    +               reduce using rule 78 (args -> tableconstructor .)
    )               reduce using rule 78 (args -> tableconstructor .)
    ,               reduce using rule 78 (args -> tableconstructor .)
    $end            reduce using rule 78 (args -> tableconstructor .)
    UNTIL           reduce using rule 78 (args -> tableconstructor .)
    ELSEIF          reduce using rule 78 (args -> tableconstructor .)
    ELSE            reduce using rule 78 (args -> tableconstructor .)
    END             reduce using rule 78 (args -> tableconstructor .)
    }               reduce using rule 78 (args -> tableconstructor .)
    ]               reduce using rule 78 (args -> tableconstructor .)
    DO              reduce using rule 78 (args -> tableconstructor .)


state 61

    (79) args -> ( . explist )
    (80) args -> ( . )
    (43) explist -> . explist , exp
    (44) explist -> . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    )               shift and go to state 115
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    explist                        shift and go to state 114
    exp                            shift and go to state 68
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 62

    (35) varlist -> varlist , . var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (40) name -> . NAME
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (               shift and go to state 15
    NAME            shift and go to state 17

    var                            shift and go to state 116
    prefixexp                      shift and go to state 117
    name                           shift and go to state 6
    functioncall                   shift and go to state 47

state 63

    (72) prefixexp -> ( exp . )
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    )               shift and go to state 118
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 64

    (2) chunk2 -> chunk2 stat optsemi .
    BREAK           reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    RETURN          reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    LOCAL           reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    FUNCTION        reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    FOR             reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    IF              reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    REPEAT          reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    {               reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    (               reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)
    NAME            reduce using rule 2 (chunk2 -> chunk2 stat optsemi .)


state 65

    (27) laststat -> BREAK optsemi .
    $end            reduce using rule 27 (laststat -> BREAK optsemi .)
    UNTIL           reduce using rule 27 (laststat -> BREAK optsemi .)
    ELSEIF          reduce using rule 27 (laststat -> BREAK optsemi .)
    ELSE            reduce using rule 27 (laststat -> BREAK optsemi .)
    END             reduce using rule 27 (laststat -> BREAK optsemi .)
    {               reduce using rule 27 (laststat -> BREAK optsemi .)


state 66

    (28) laststat -> RETURN explist .
    (43) explist -> explist . , exp
    $end            reduce using rule 28 (laststat -> RETURN explist .)
    UNTIL           reduce using rule 28 (laststat -> RETURN explist .)
    ELSEIF          reduce using rule 28 (laststat -> RETURN explist .)
    ELSE            reduce using rule 28 (laststat -> RETURN explist .)
    END             reduce using rule 28 (laststat -> RETURN explist .)
    {               reduce using rule 28 (laststat -> RETURN explist .)
    ,               shift and go to state 119


state 67

    (29) laststat -> RETURN optsemi .
    $end            reduce using rule 29 (laststat -> RETURN optsemi .)
    UNTIL           reduce using rule 29 (laststat -> RETURN optsemi .)
    ELSEIF          reduce using rule 29 (laststat -> RETURN optsemi .)
    ELSE            reduce using rule 29 (laststat -> RETURN optsemi .)
    END             reduce using rule 29 (laststat -> RETURN optsemi .)
    {               reduce using rule 29 (laststat -> RETURN optsemi .)


state 68

    (44) explist -> exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    ,               reduce using rule 44 (explist -> exp .)
    $end            reduce using rule 44 (explist -> exp .)
    UNTIL           reduce using rule 44 (explist -> exp .)
    ELSEIF          reduce using rule 44 (explist -> exp .)
    ELSE            reduce using rule 44 (explist -> exp .)
    END             reduce using rule 44 (explist -> exp .)
    {               reduce using rule 44 (explist -> exp .)
    ;               reduce using rule 44 (explist -> exp .)
    BREAK           reduce using rule 44 (explist -> exp .)
    RETURN          reduce using rule 44 (explist -> exp .)
    LOCAL           reduce using rule 44 (explist -> exp .)
    FUNCTION        reduce using rule 44 (explist -> exp .)
    FOR             reduce using rule 44 (explist -> exp .)
    IF              reduce using rule 44 (explist -> exp .)
    REPEAT          reduce using rule 44 (explist -> exp .)
    (               reduce using rule 44 (explist -> exp .)
    NAME            reduce using rule 44 (explist -> exp .)
    )               reduce using rule 44 (explist -> exp .)
    DO              reduce using rule 44 (explist -> exp .)
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 69

    (7) stat -> LOCAL namelist = . explist
    (43) explist -> . explist , exp
    (44) explist -> . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    explist                        shift and go to state 120
    exp                            shift and go to state 68
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 70

    (42) namelist -> namelist , . name
    (40) name -> . NAME
    NAME            shift and go to state 17

    name                           shift and go to state 121

state 71

    (9) stat -> LOCAL FUNCTION name . funcbody
    (82) funcbody -> . ( ) block END
    (83) funcbody -> . ( parlist ) block END
    (               shift and go to state 106

    funcbody                       shift and go to state 122

state 72

    (10) stat -> FUNCTION funcname args .
    ;               reduce using rule 10 (stat -> FUNCTION funcname args .)
    BREAK           reduce using rule 10 (stat -> FUNCTION funcname args .)
    RETURN          reduce using rule 10 (stat -> FUNCTION funcname args .)
    LOCAL           reduce using rule 10 (stat -> FUNCTION funcname args .)
    FUNCTION        reduce using rule 10 (stat -> FUNCTION funcname args .)
    FOR             reduce using rule 10 (stat -> FUNCTION funcname args .)
    IF              reduce using rule 10 (stat -> FUNCTION funcname args .)
    REPEAT          reduce using rule 10 (stat -> FUNCTION funcname args .)
    {               reduce using rule 10 (stat -> FUNCTION funcname args .)
    (               reduce using rule 10 (stat -> FUNCTION funcname args .)
    NAME            reduce using rule 10 (stat -> FUNCTION funcname args .)


state 73

    (11) stat -> FUNCTION funcname funcbody .
    ;               reduce using rule 11 (stat -> FUNCTION funcname funcbody .)
    BREAK           reduce using rule 11 (stat -> FUNCTION funcname funcbody .)
    RETURN          reduce using rule 11 (stat -> FUNCTION funcname funcbody .)
    LOCAL           reduce using rule 11 (stat -> FUNCTION funcname funcbody .)
    FUNCTION        reduce using rule 11 (stat -> FUNCTION funcname funcbody .)
    FOR             reduce using rule 11 (stat -> FUNCTION funcname funcbody .)
    IF              reduce using rule 11 (stat -> FUNCTION funcname funcbody .)
    REPEAT          reduce using rule 11 (stat -> FUNCTION funcname funcbody .)
    {               reduce using rule 11 (stat -> FUNCTION funcname funcbody .)
    (               reduce using rule 11 (stat -> FUNCTION funcname funcbody .)
    NAME            reduce using rule 11 (stat -> FUNCTION funcname funcbody .)


state 74

    (79) args -> ( . explist )
    (80) args -> ( . )
    (82) funcbody -> ( . ) block END
    (83) funcbody -> ( . parlist ) block END
    (43) explist -> . explist , exp
    (44) explist -> . exp
    (84) parlist -> . VARARG
    (85) parlist -> . namelist , VARARG
    (86) parlist -> . empty
    (87) parlist -> . namelist
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (41) namelist -> . name
    (42) namelist -> . namelist , name
    (100) empty -> .
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (40) name -> . NAME
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 123
    VARARG          shift and go to state 125
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    explist                        shift and go to state 114
    parlist                        shift and go to state 124
    exp                            shift and go to state 68
    namelist                       shift and go to state 126
    empty                          shift and go to state 127
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    name                           shift and go to state 128
    functioncall                   shift and go to state 47
    var                            shift and go to state 48

state 75

    (31) funcname -> funcname2 : . name
    (40) name -> . NAME
    NAME            shift and go to state 17

    name                           shift and go to state 129

state 76

    (32) funcname2 -> funcname2 . . name
    (40) name -> . NAME
    NAME            shift and go to state 17

    name                           shift and go to state 130

state 77

    (12) stat -> FOR namelist IN . explist DO block END
    (43) explist -> . explist , exp
    (44) explist -> . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    explist                        shift and go to state 131
    exp                            shift and go to state 68
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 78

    (13) stat -> FOR name = . exp , exp , exp DO block END
    (14) stat -> FOR name = . exp , exp DO block END
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    name                           shift and go to state 6
    exp                            shift and go to state 132
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48

state 79

    (15) stat -> IF exp THEN . block elseiflist _else END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 133
    chunk                          shift and go to state 51
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 80

    (48) exp -> exp OR . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 134
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 81

    (49) exp -> exp AND . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 135
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 82

    (50) exp -> exp NE . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 136
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 83

    (51) exp -> exp EQ . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 137
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 84

    (52) exp -> exp GE . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 138
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 85

    (53) exp -> exp GT . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 139
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 86

    (54) exp -> exp LE . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 140
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 87

    (55) exp -> exp LT . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 141
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 88

    (56) exp -> exp CONCAT . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 142
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 89

    (57) exp -> exp % . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 143
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 90

    (58) exp -> exp ^ . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 144
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 91

    (59) exp -> exp / . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 145
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 92

    (60) exp -> exp * . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 146
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 93

    (61) exp -> exp - . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 147
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 94

    (62) exp -> exp + . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 148
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 95

    (45) exp -> # exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 45 (exp -> # exp .)
    OR              reduce using rule 45 (exp -> # exp .)
    AND             reduce using rule 45 (exp -> # exp .)
    NE              reduce using rule 45 (exp -> # exp .)
    EQ              reduce using rule 45 (exp -> # exp .)
    GE              reduce using rule 45 (exp -> # exp .)
    GT              reduce using rule 45 (exp -> # exp .)
    LE              reduce using rule 45 (exp -> # exp .)
    LT              reduce using rule 45 (exp -> # exp .)
    CONCAT          reduce using rule 45 (exp -> # exp .)
    %               reduce using rule 45 (exp -> # exp .)
    /               reduce using rule 45 (exp -> # exp .)
    *               reduce using rule 45 (exp -> # exp .)
    -               reduce using rule 45 (exp -> # exp .)
    +               reduce using rule 45 (exp -> # exp .)
    )               reduce using rule 45 (exp -> # exp .)
    ,               reduce using rule 45 (exp -> # exp .)
    $end            reduce using rule 45 (exp -> # exp .)
    UNTIL           reduce using rule 45 (exp -> # exp .)
    ELSEIF          reduce using rule 45 (exp -> # exp .)
    ELSE            reduce using rule 45 (exp -> # exp .)
    END             reduce using rule 45 (exp -> # exp .)
    {               reduce using rule 45 (exp -> # exp .)
    ;               reduce using rule 45 (exp -> # exp .)
    }               reduce using rule 45 (exp -> # exp .)
    BREAK           reduce using rule 45 (exp -> # exp .)
    RETURN          reduce using rule 45 (exp -> # exp .)
    LOCAL           reduce using rule 45 (exp -> # exp .)
    FUNCTION        reduce using rule 45 (exp -> # exp .)
    FOR             reduce using rule 45 (exp -> # exp .)
    IF              reduce using rule 45 (exp -> # exp .)
    REPEAT          reduce using rule 45 (exp -> # exp .)
    (               reduce using rule 45 (exp -> # exp .)
    NAME            reduce using rule 45 (exp -> # exp .)
    ]               reduce using rule 45 (exp -> # exp .)
    DO              reduce using rule 45 (exp -> # exp .)
    ^               shift and go to state 90


state 96

    (46) exp -> NOT exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 46 (exp -> NOT exp .)
    OR              reduce using rule 46 (exp -> NOT exp .)
    AND             reduce using rule 46 (exp -> NOT exp .)
    NE              reduce using rule 46 (exp -> NOT exp .)
    EQ              reduce using rule 46 (exp -> NOT exp .)
    GE              reduce using rule 46 (exp -> NOT exp .)
    GT              reduce using rule 46 (exp -> NOT exp .)
    LE              reduce using rule 46 (exp -> NOT exp .)
    LT              reduce using rule 46 (exp -> NOT exp .)
    CONCAT          reduce using rule 46 (exp -> NOT exp .)
    %               reduce using rule 46 (exp -> NOT exp .)
    /               reduce using rule 46 (exp -> NOT exp .)
    *               reduce using rule 46 (exp -> NOT exp .)
    -               reduce using rule 46 (exp -> NOT exp .)
    +               reduce using rule 46 (exp -> NOT exp .)
    )               reduce using rule 46 (exp -> NOT exp .)
    ,               reduce using rule 46 (exp -> NOT exp .)
    $end            reduce using rule 46 (exp -> NOT exp .)
    UNTIL           reduce using rule 46 (exp -> NOT exp .)
    ELSEIF          reduce using rule 46 (exp -> NOT exp .)
    ELSE            reduce using rule 46 (exp -> NOT exp .)
    END             reduce using rule 46 (exp -> NOT exp .)
    {               reduce using rule 46 (exp -> NOT exp .)
    ;               reduce using rule 46 (exp -> NOT exp .)
    }               reduce using rule 46 (exp -> NOT exp .)
    BREAK           reduce using rule 46 (exp -> NOT exp .)
    RETURN          reduce using rule 46 (exp -> NOT exp .)
    LOCAL           reduce using rule 46 (exp -> NOT exp .)
    FUNCTION        reduce using rule 46 (exp -> NOT exp .)
    FOR             reduce using rule 46 (exp -> NOT exp .)
    IF              reduce using rule 46 (exp -> NOT exp .)
    REPEAT          reduce using rule 46 (exp -> NOT exp .)
    (               reduce using rule 46 (exp -> NOT exp .)
    NAME            reduce using rule 46 (exp -> NOT exp .)
    ]               reduce using rule 46 (exp -> NOT exp .)
    DO              reduce using rule 46 (exp -> NOT exp .)
    ^               shift and go to state 90


state 97

    (47) exp -> - exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 47 (exp -> - exp .)
    OR              reduce using rule 47 (exp -> - exp .)
    AND             reduce using rule 47 (exp -> - exp .)
    NE              reduce using rule 47 (exp -> - exp .)
    EQ              reduce using rule 47 (exp -> - exp .)
    GE              reduce using rule 47 (exp -> - exp .)
    GT              reduce using rule 47 (exp -> - exp .)
    LE              reduce using rule 47 (exp -> - exp .)
    LT              reduce using rule 47 (exp -> - exp .)
    CONCAT          reduce using rule 47 (exp -> - exp .)
    %               reduce using rule 47 (exp -> - exp .)
    /               reduce using rule 47 (exp -> - exp .)
    *               reduce using rule 47 (exp -> - exp .)
    -               reduce using rule 47 (exp -> - exp .)
    +               reduce using rule 47 (exp -> - exp .)
    )               reduce using rule 47 (exp -> - exp .)
    ,               reduce using rule 47 (exp -> - exp .)
    $end            reduce using rule 47 (exp -> - exp .)
    UNTIL           reduce using rule 47 (exp -> - exp .)
    ELSEIF          reduce using rule 47 (exp -> - exp .)
    ELSE            reduce using rule 47 (exp -> - exp .)
    END             reduce using rule 47 (exp -> - exp .)
    {               reduce using rule 47 (exp -> - exp .)
    ;               reduce using rule 47 (exp -> - exp .)
    }               reduce using rule 47 (exp -> - exp .)
    BREAK           reduce using rule 47 (exp -> - exp .)
    RETURN          reduce using rule 47 (exp -> - exp .)
    LOCAL           reduce using rule 47 (exp -> - exp .)
    FUNCTION        reduce using rule 47 (exp -> - exp .)
    FOR             reduce using rule 47 (exp -> - exp .)
    IF              reduce using rule 47 (exp -> - exp .)
    REPEAT          reduce using rule 47 (exp -> - exp .)
    (               reduce using rule 47 (exp -> - exp .)
    NAME            reduce using rule 47 (exp -> - exp .)
    ]               reduce using rule 47 (exp -> - exp .)
    DO              reduce using rule 47 (exp -> - exp .)
    ^               shift and go to state 90


state 98

    (88) tableconstructor -> { } .
    THEN            reduce using rule 88 (tableconstructor -> { } .)
    OR              reduce using rule 88 (tableconstructor -> { } .)
    AND             reduce using rule 88 (tableconstructor -> { } .)
    NE              reduce using rule 88 (tableconstructor -> { } .)
    EQ              reduce using rule 88 (tableconstructor -> { } .)
    GE              reduce using rule 88 (tableconstructor -> { } .)
    GT              reduce using rule 88 (tableconstructor -> { } .)
    LE              reduce using rule 88 (tableconstructor -> { } .)
    LT              reduce using rule 88 (tableconstructor -> { } .)
    CONCAT          reduce using rule 88 (tableconstructor -> { } .)
    %               reduce using rule 88 (tableconstructor -> { } .)
    ^               reduce using rule 88 (tableconstructor -> { } .)
    /               reduce using rule 88 (tableconstructor -> { } .)
    *               reduce using rule 88 (tableconstructor -> { } .)
    -               reduce using rule 88 (tableconstructor -> { } .)
    +               reduce using rule 88 (tableconstructor -> { } .)
    ;               reduce using rule 88 (tableconstructor -> { } .)
    BREAK           reduce using rule 88 (tableconstructor -> { } .)
    RETURN          reduce using rule 88 (tableconstructor -> { } .)
    LOCAL           reduce using rule 88 (tableconstructor -> { } .)
    FUNCTION        reduce using rule 88 (tableconstructor -> { } .)
    FOR             reduce using rule 88 (tableconstructor -> { } .)
    IF              reduce using rule 88 (tableconstructor -> { } .)
    REPEAT          reduce using rule 88 (tableconstructor -> { } .)
    {               reduce using rule 88 (tableconstructor -> { } .)
    (               reduce using rule 88 (tableconstructor -> { } .)
    NAME            reduce using rule 88 (tableconstructor -> { } .)
    :               reduce using rule 88 (tableconstructor -> { } .)
    .               reduce using rule 88 (tableconstructor -> { } .)
    [               reduce using rule 88 (tableconstructor -> { } .)
    STRING          reduce using rule 88 (tableconstructor -> { } .)
    )               reduce using rule 88 (tableconstructor -> { } .)
    ,               reduce using rule 88 (tableconstructor -> { } .)
    $end            reduce using rule 88 (tableconstructor -> { } .)
    UNTIL           reduce using rule 88 (tableconstructor -> { } .)
    ELSEIF          reduce using rule 88 (tableconstructor -> { } .)
    ELSE            reduce using rule 88 (tableconstructor -> { } .)
    END             reduce using rule 88 (tableconstructor -> { } .)
    }               reduce using rule 88 (tableconstructor -> { } .)
    ]               reduce using rule 88 (tableconstructor -> { } .)
    DO              reduce using rule 88 (tableconstructor -> { } .)


state 99

    (89) tableconstructor -> { fieldlist . }
    }               shift and go to state 149


state 100

    (90) fieldlist -> fieldlist2 . optfieldsep
    (91) fieldlist2 -> fieldlist2 . fieldsep field
    (96) optfieldsep -> . empty
    (97) optfieldsep -> . fieldsep
    (98) fieldsep -> . ;
    (99) fieldsep -> . ,
    (100) empty -> .
    ;               shift and go to state 153
    ,               shift and go to state 154
    }               reduce using rule 100 (empty -> .)

    optfieldsep                    shift and go to state 150
    fieldsep                       shift and go to state 151
    empty                          shift and go to state 152

state 101

    (92) fieldlist2 -> field .
    ;               reduce using rule 92 (fieldlist2 -> field .)
    ,               reduce using rule 92 (fieldlist2 -> field .)
    }               reduce using rule 92 (fieldlist2 -> field .)


state 102

    (93) field -> exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    ;               reduce using rule 93 (field -> exp .)
    ,               reduce using rule 93 (field -> exp .)
    }               reduce using rule 93 (field -> exp .)
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 103

    (94) field -> NAME . = exp
    (40) name -> NAME .
    =               shift and go to state 155
    :               reduce using rule 40 (name -> NAME .)
    .               reduce using rule 40 (name -> NAME .)
    [               reduce using rule 40 (name -> NAME .)
    STRING          reduce using rule 40 (name -> NAME .)
    (               reduce using rule 40 (name -> NAME .)
    {               reduce using rule 40 (name -> NAME .)
    OR              reduce using rule 40 (name -> NAME .)
    AND             reduce using rule 40 (name -> NAME .)
    NE              reduce using rule 40 (name -> NAME .)
    EQ              reduce using rule 40 (name -> NAME .)
    GE              reduce using rule 40 (name -> NAME .)
    GT              reduce using rule 40 (name -> NAME .)
    LE              reduce using rule 40 (name -> NAME .)
    LT              reduce using rule 40 (name -> NAME .)
    CONCAT          reduce using rule 40 (name -> NAME .)
    %               reduce using rule 40 (name -> NAME .)
    ^               reduce using rule 40 (name -> NAME .)
    /               reduce using rule 40 (name -> NAME .)
    *               reduce using rule 40 (name -> NAME .)
    -               reduce using rule 40 (name -> NAME .)
    +               reduce using rule 40 (name -> NAME .)
    ;               reduce using rule 40 (name -> NAME .)
    ,               reduce using rule 40 (name -> NAME .)
    }               reduce using rule 40 (name -> NAME .)


state 104

    (95) field -> [ . exp ] = exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 156
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 105

    (81) function -> FUNCTION funcbody .
    THEN            reduce using rule 81 (function -> FUNCTION funcbody .)
    OR              reduce using rule 81 (function -> FUNCTION funcbody .)
    AND             reduce using rule 81 (function -> FUNCTION funcbody .)
    NE              reduce using rule 81 (function -> FUNCTION funcbody .)
    EQ              reduce using rule 81 (function -> FUNCTION funcbody .)
    GE              reduce using rule 81 (function -> FUNCTION funcbody .)
    GT              reduce using rule 81 (function -> FUNCTION funcbody .)
    LE              reduce using rule 81 (function -> FUNCTION funcbody .)
    LT              reduce using rule 81 (function -> FUNCTION funcbody .)
    CONCAT          reduce using rule 81 (function -> FUNCTION funcbody .)
    %               reduce using rule 81 (function -> FUNCTION funcbody .)
    ^               reduce using rule 81 (function -> FUNCTION funcbody .)
    /               reduce using rule 81 (function -> FUNCTION funcbody .)
    *               reduce using rule 81 (function -> FUNCTION funcbody .)
    -               reduce using rule 81 (function -> FUNCTION funcbody .)
    +               reduce using rule 81 (function -> FUNCTION funcbody .)
    )               reduce using rule 81 (function -> FUNCTION funcbody .)
    ,               reduce using rule 81 (function -> FUNCTION funcbody .)
    $end            reduce using rule 81 (function -> FUNCTION funcbody .)
    UNTIL           reduce using rule 81 (function -> FUNCTION funcbody .)
    ELSEIF          reduce using rule 81 (function -> FUNCTION funcbody .)
    ELSE            reduce using rule 81 (function -> FUNCTION funcbody .)
    END             reduce using rule 81 (function -> FUNCTION funcbody .)
    {               reduce using rule 81 (function -> FUNCTION funcbody .)
    ;               reduce using rule 81 (function -> FUNCTION funcbody .)
    }               reduce using rule 81 (function -> FUNCTION funcbody .)
    BREAK           reduce using rule 81 (function -> FUNCTION funcbody .)
    RETURN          reduce using rule 81 (function -> FUNCTION funcbody .)
    LOCAL           reduce using rule 81 (function -> FUNCTION funcbody .)
    FUNCTION        reduce using rule 81 (function -> FUNCTION funcbody .)
    FOR             reduce using rule 81 (function -> FUNCTION funcbody .)
    IF              reduce using rule 81 (function -> FUNCTION funcbody .)
    REPEAT          reduce using rule 81 (function -> FUNCTION funcbody .)
    (               reduce using rule 81 (function -> FUNCTION funcbody .)
    NAME            reduce using rule 81 (function -> FUNCTION funcbody .)
    ]               reduce using rule 81 (function -> FUNCTION funcbody .)
    DO              reduce using rule 81 (function -> FUNCTION funcbody .)


state 106

    (82) funcbody -> ( . ) block END
    (83) funcbody -> ( . parlist ) block END
    (84) parlist -> . VARARG
    (85) parlist -> . namelist , VARARG
    (86) parlist -> . empty
    (87) parlist -> . namelist
    (41) namelist -> . name
    (42) namelist -> . namelist , name
    (100) empty -> .
    (40) name -> . NAME
  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 157
    VARARG          shift and go to state 158
    NAME            shift and go to state 17

    parlist                        shift and go to state 124
    namelist                       shift and go to state 126
    empty                          shift and go to state 127
    name                           shift and go to state 27

state 107

    (16) stat -> REPEAT block UNTIL . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 159
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 108

    (17) stat -> { WHILE } . exp { DO } block { END }
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 160
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 109

    (18) stat -> { DO } . block { END }
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 161
    chunk                          shift and go to state 51
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 110

    (20) stat -> location = explist .
    (43) explist -> explist . , exp
    ;               reduce using rule 20 (stat -> location = explist .)
    BREAK           reduce using rule 20 (stat -> location = explist .)
    RETURN          reduce using rule 20 (stat -> location = explist .)
    LOCAL           reduce using rule 20 (stat -> location = explist .)
    FUNCTION        reduce using rule 20 (stat -> location = explist .)
    FOR             reduce using rule 20 (stat -> location = explist .)
    IF              reduce using rule 20 (stat -> location = explist .)
    REPEAT          reduce using rule 20 (stat -> location = explist .)
    {               reduce using rule 20 (stat -> location = explist .)
    (               reduce using rule 20 (stat -> location = explist .)
    NAME            reduce using rule 20 (stat -> location = explist .)
    ,               shift and go to state 119


state 111

    (75) functioncall -> prefixexp : name . args
    (77) args -> . STRING
    (78) args -> . tableconstructor
    (79) args -> . ( explist )
    (80) args -> . ( )
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    STRING          shift and go to state 59
    (               shift and go to state 61
    {               shift and go to state 46

    args                           shift and go to state 162
    tableconstructor               shift and go to state 60

state 112

    (36) var -> prefixexp . name .
    :               reduce using rule 36 (var -> prefixexp . name .)
    .               reduce using rule 36 (var -> prefixexp . name .)
    [               reduce using rule 36 (var -> prefixexp . name .)
    STRING          reduce using rule 36 (var -> prefixexp . name .)
    (               reduce using rule 36 (var -> prefixexp . name .)
    {               reduce using rule 36 (var -> prefixexp . name .)
    ,               reduce using rule 36 (var -> prefixexp . name .)
    =               reduce using rule 36 (var -> prefixexp . name .)
    THEN            reduce using rule 36 (var -> prefixexp . name .)
    OR              reduce using rule 36 (var -> prefixexp . name .)
    AND             reduce using rule 36 (var -> prefixexp . name .)
    NE              reduce using rule 36 (var -> prefixexp . name .)
    EQ              reduce using rule 36 (var -> prefixexp . name .)
    GE              reduce using rule 36 (var -> prefixexp . name .)
    GT              reduce using rule 36 (var -> prefixexp . name .)
    LE              reduce using rule 36 (var -> prefixexp . name .)
    LT              reduce using rule 36 (var -> prefixexp . name .)
    CONCAT          reduce using rule 36 (var -> prefixexp . name .)
    %               reduce using rule 36 (var -> prefixexp . name .)
    ^               reduce using rule 36 (var -> prefixexp . name .)
    /               reduce using rule 36 (var -> prefixexp . name .)
    *               reduce using rule 36 (var -> prefixexp . name .)
    -               reduce using rule 36 (var -> prefixexp . name .)
    +               reduce using rule 36 (var -> prefixexp . name .)
    )               reduce using rule 36 (var -> prefixexp . name .)
    $end            reduce using rule 36 (var -> prefixexp . name .)
    UNTIL           reduce using rule 36 (var -> prefixexp . name .)
    ELSEIF          reduce using rule 36 (var -> prefixexp . name .)
    ELSE            reduce using rule 36 (var -> prefixexp . name .)
    END             reduce using rule 36 (var -> prefixexp . name .)
    ;               reduce using rule 36 (var -> prefixexp . name .)
    }               reduce using rule 36 (var -> prefixexp . name .)
    BREAK           reduce using rule 36 (var -> prefixexp . name .)
    RETURN          reduce using rule 36 (var -> prefixexp . name .)
    LOCAL           reduce using rule 36 (var -> prefixexp . name .)
    FUNCTION        reduce using rule 36 (var -> prefixexp . name .)
    FOR             reduce using rule 36 (var -> prefixexp . name .)
    IF              reduce using rule 36 (var -> prefixexp . name .)
    REPEAT          reduce using rule 36 (var -> prefixexp . name .)
    NAME            reduce using rule 36 (var -> prefixexp . name .)
    ]               reduce using rule 36 (var -> prefixexp . name .)
    DO              reduce using rule 36 (var -> prefixexp . name .)


state 113

    (37) var -> prefixexp [ exp . ]
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    ]               shift and go to state 163
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 114

    (79) args -> ( explist . )
    (43) explist -> explist . , exp
    )               shift and go to state 164
    ,               shift and go to state 119


state 115

    (80) args -> ( ) .
    ;               reduce using rule 80 (args -> ( ) .)
    BREAK           reduce using rule 80 (args -> ( ) .)
    RETURN          reduce using rule 80 (args -> ( ) .)
    LOCAL           reduce using rule 80 (args -> ( ) .)
    FUNCTION        reduce using rule 80 (args -> ( ) .)
    FOR             reduce using rule 80 (args -> ( ) .)
    IF              reduce using rule 80 (args -> ( ) .)
    REPEAT          reduce using rule 80 (args -> ( ) .)
    {               reduce using rule 80 (args -> ( ) .)
    (               reduce using rule 80 (args -> ( ) .)
    NAME            reduce using rule 80 (args -> ( ) .)
    :               reduce using rule 80 (args -> ( ) .)
    .               reduce using rule 80 (args -> ( ) .)
    [               reduce using rule 80 (args -> ( ) .)
    STRING          reduce using rule 80 (args -> ( ) .)
    THEN            reduce using rule 80 (args -> ( ) .)
    OR              reduce using rule 80 (args -> ( ) .)
    AND             reduce using rule 80 (args -> ( ) .)
    NE              reduce using rule 80 (args -> ( ) .)
    EQ              reduce using rule 80 (args -> ( ) .)
    GE              reduce using rule 80 (args -> ( ) .)
    GT              reduce using rule 80 (args -> ( ) .)
    LE              reduce using rule 80 (args -> ( ) .)
    LT              reduce using rule 80 (args -> ( ) .)
    CONCAT          reduce using rule 80 (args -> ( ) .)
    %               reduce using rule 80 (args -> ( ) .)
    ^               reduce using rule 80 (args -> ( ) .)
    /               reduce using rule 80 (args -> ( ) .)
    *               reduce using rule 80 (args -> ( ) .)
    -               reduce using rule 80 (args -> ( ) .)
    +               reduce using rule 80 (args -> ( ) .)
    )               reduce using rule 80 (args -> ( ) .)
    ,               reduce using rule 80 (args -> ( ) .)
    $end            reduce using rule 80 (args -> ( ) .)
    UNTIL           reduce using rule 80 (args -> ( ) .)
    ELSEIF          reduce using rule 80 (args -> ( ) .)
    ELSE            reduce using rule 80 (args -> ( ) .)
    END             reduce using rule 80 (args -> ( ) .)
    }               reduce using rule 80 (args -> ( ) .)
    ]               reduce using rule 80 (args -> ( ) .)
    DO              reduce using rule 80 (args -> ( ) .)


state 116

    (35) varlist -> varlist , var .
    (74) prefixexp -> var .
    ,               reduce using rule 35 (varlist -> varlist , var .)
    =               reduce using rule 35 (varlist -> varlist , var .)
    .               reduce using rule 74 (prefixexp -> var .)
    [               reduce using rule 74 (prefixexp -> var .)
    :               reduce using rule 74 (prefixexp -> var .)
    STRING          reduce using rule 74 (prefixexp -> var .)
    (               reduce using rule 74 (prefixexp -> var .)
    {               reduce using rule 74 (prefixexp -> var .)


state 117

    (36) var -> prefixexp . . name
    (37) var -> prefixexp . [ exp ]
    (75) functioncall -> prefixexp . : name args
    (76) functioncall -> prefixexp . args
    (77) args -> . STRING
    (78) args -> . tableconstructor
    (79) args -> . ( explist )
    (80) args -> . ( )
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    .               shift and go to state 57
    [               shift and go to state 58
    :               shift and go to state 55
    STRING          shift and go to state 59
    (               shift and go to state 61
    {               shift and go to state 46

    args                           shift and go to state 56
    tableconstructor               shift and go to state 60

state 118

    (72) prefixexp -> ( exp ) .
    :               reduce using rule 72 (prefixexp -> ( exp ) .)
    .               reduce using rule 72 (prefixexp -> ( exp ) .)
    [               reduce using rule 72 (prefixexp -> ( exp ) .)
    STRING          reduce using rule 72 (prefixexp -> ( exp ) .)
    (               reduce using rule 72 (prefixexp -> ( exp ) .)
    {               reduce using rule 72 (prefixexp -> ( exp ) .)
    THEN            reduce using rule 72 (prefixexp -> ( exp ) .)
    OR              reduce using rule 72 (prefixexp -> ( exp ) .)
    AND             reduce using rule 72 (prefixexp -> ( exp ) .)
    NE              reduce using rule 72 (prefixexp -> ( exp ) .)
    EQ              reduce using rule 72 (prefixexp -> ( exp ) .)
    GE              reduce using rule 72 (prefixexp -> ( exp ) .)
    GT              reduce using rule 72 (prefixexp -> ( exp ) .)
    LE              reduce using rule 72 (prefixexp -> ( exp ) .)
    LT              reduce using rule 72 (prefixexp -> ( exp ) .)
    CONCAT          reduce using rule 72 (prefixexp -> ( exp ) .)
    %               reduce using rule 72 (prefixexp -> ( exp ) .)
    ^               reduce using rule 72 (prefixexp -> ( exp ) .)
    /               reduce using rule 72 (prefixexp -> ( exp ) .)
    *               reduce using rule 72 (prefixexp -> ( exp ) .)
    -               reduce using rule 72 (prefixexp -> ( exp ) .)
    +               reduce using rule 72 (prefixexp -> ( exp ) .)
    )               reduce using rule 72 (prefixexp -> ( exp ) .)
    ,               reduce using rule 72 (prefixexp -> ( exp ) .)
    $end            reduce using rule 72 (prefixexp -> ( exp ) .)
    UNTIL           reduce using rule 72 (prefixexp -> ( exp ) .)
    ELSEIF          reduce using rule 72 (prefixexp -> ( exp ) .)
    ELSE            reduce using rule 72 (prefixexp -> ( exp ) .)
    END             reduce using rule 72 (prefixexp -> ( exp ) .)
    ;               reduce using rule 72 (prefixexp -> ( exp ) .)
    }               reduce using rule 72 (prefixexp -> ( exp ) .)
    BREAK           reduce using rule 72 (prefixexp -> ( exp ) .)
    RETURN          reduce using rule 72 (prefixexp -> ( exp ) .)
    LOCAL           reduce using rule 72 (prefixexp -> ( exp ) .)
    FUNCTION        reduce using rule 72 (prefixexp -> ( exp ) .)
    FOR             reduce using rule 72 (prefixexp -> ( exp ) .)
    IF              reduce using rule 72 (prefixexp -> ( exp ) .)
    REPEAT          reduce using rule 72 (prefixexp -> ( exp ) .)
    NAME            reduce using rule 72 (prefixexp -> ( exp ) .)
    ]               reduce using rule 72 (prefixexp -> ( exp ) .)
    DO              reduce using rule 72 (prefixexp -> ( exp ) .)


state 119

    (43) explist -> explist , . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 165
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 120

    (7) stat -> LOCAL namelist = explist .
    (43) explist -> explist . , exp
    ;               reduce using rule 7 (stat -> LOCAL namelist = explist .)
    BREAK           reduce using rule 7 (stat -> LOCAL namelist = explist .)
    RETURN          reduce using rule 7 (stat -> LOCAL namelist = explist .)
    LOCAL           reduce using rule 7 (stat -> LOCAL namelist = explist .)
    FUNCTION        reduce using rule 7 (stat -> LOCAL namelist = explist .)
    FOR             reduce using rule 7 (stat -> LOCAL namelist = explist .)
    IF              reduce using rule 7 (stat -> LOCAL namelist = explist .)
    REPEAT          reduce using rule 7 (stat -> LOCAL namelist = explist .)
    {               reduce using rule 7 (stat -> LOCAL namelist = explist .)
    (               reduce using rule 7 (stat -> LOCAL namelist = explist .)
    NAME            reduce using rule 7 (stat -> LOCAL namelist = explist .)
    ,               shift and go to state 119


state 121

    (42) namelist -> namelist , name .
    =               reduce using rule 42 (namelist -> namelist , name .)
    ,               reduce using rule 42 (namelist -> namelist , name .)
    ;               reduce using rule 42 (namelist -> namelist , name .)
    BREAK           reduce using rule 42 (namelist -> namelist , name .)
    RETURN          reduce using rule 42 (namelist -> namelist , name .)
    LOCAL           reduce using rule 42 (namelist -> namelist , name .)
    FUNCTION        reduce using rule 42 (namelist -> namelist , name .)
    FOR             reduce using rule 42 (namelist -> namelist , name .)
    IF              reduce using rule 42 (namelist -> namelist , name .)
    REPEAT          reduce using rule 42 (namelist -> namelist , name .)
    {               reduce using rule 42 (namelist -> namelist , name .)
    (               reduce using rule 42 (namelist -> namelist , name .)
    NAME            reduce using rule 42 (namelist -> namelist , name .)
    IN              reduce using rule 42 (namelist -> namelist , name .)
    )               reduce using rule 42 (namelist -> namelist , name .)


state 122

    (9) stat -> LOCAL FUNCTION name funcbody .
    ;               reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    BREAK           reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    RETURN          reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    LOCAL           reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    FUNCTION        reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    FOR             reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    IF              reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    REPEAT          reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    {               reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    (               reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)
    NAME            reduce using rule 9 (stat -> LOCAL FUNCTION name funcbody .)


state 123

    (80) args -> ( ) .
    (82) funcbody -> ( ) . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
  ! shift/reduce conflict for LOCAL resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NAME resolved as shift
    ;               reduce using rule 80 (args -> ( ) .)
    BREAK           reduce using rule 80 (args -> ( ) .)
    RETURN          reduce using rule 80 (args -> ( ) .)
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 166
    chunk                          shift and go to state 51
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 124

    (83) funcbody -> ( parlist . ) block END
    )               shift and go to state 167


state 125

    (84) parlist -> VARARG .
    (66) exp -> VARARG .
  ! reduce/reduce conflict for ) resolved using rule 66 (exp -> VARARG .)
    OR              reduce using rule 66 (exp -> VARARG .)
    AND             reduce using rule 66 (exp -> VARARG .)
    NE              reduce using rule 66 (exp -> VARARG .)
    EQ              reduce using rule 66 (exp -> VARARG .)
    GE              reduce using rule 66 (exp -> VARARG .)
    GT              reduce using rule 66 (exp -> VARARG .)
    LE              reduce using rule 66 (exp -> VARARG .)
    LT              reduce using rule 66 (exp -> VARARG .)
    CONCAT          reduce using rule 66 (exp -> VARARG .)
    %               reduce using rule 66 (exp -> VARARG .)
    ^               reduce using rule 66 (exp -> VARARG .)
    /               reduce using rule 66 (exp -> VARARG .)
    *               reduce using rule 66 (exp -> VARARG .)
    -               reduce using rule 66 (exp -> VARARG .)
    +               reduce using rule 66 (exp -> VARARG .)
    )               reduce using rule 66 (exp -> VARARG .)
    ,               reduce using rule 66 (exp -> VARARG .)


state 126

    (85) parlist -> namelist . , VARARG
    (87) parlist -> namelist .
    (42) namelist -> namelist . , name
    ,               shift and go to state 168
    )               reduce using rule 87 (parlist -> namelist .)


state 127

    (86) parlist -> empty .
    )               reduce using rule 86 (parlist -> empty .)


state 128

    (41) namelist -> name .
    (38) var -> name .
  ! reduce/reduce conflict for ) resolved using rule 38 (var -> name .)
  ! reduce/reduce conflict for , resolved using rule 38 (var -> name .)
    :               reduce using rule 38 (var -> name .)
    .               reduce using rule 38 (var -> name .)
    [               reduce using rule 38 (var -> name .)
    STRING          reduce using rule 38 (var -> name .)
    (               reduce using rule 38 (var -> name .)
    {               reduce using rule 38 (var -> name .)
    OR              reduce using rule 38 (var -> name .)
    AND             reduce using rule 38 (var -> name .)
    NE              reduce using rule 38 (var -> name .)
    EQ              reduce using rule 38 (var -> name .)
    GE              reduce using rule 38 (var -> name .)
    GT              reduce using rule 38 (var -> name .)
    LE              reduce using rule 38 (var -> name .)
    LT              reduce using rule 38 (var -> name .)
    CONCAT          reduce using rule 38 (var -> name .)
    %               reduce using rule 38 (var -> name .)
    ^               reduce using rule 38 (var -> name .)
    /               reduce using rule 38 (var -> name .)
    *               reduce using rule 38 (var -> name .)
    -               reduce using rule 38 (var -> name .)
    +               reduce using rule 38 (var -> name .)
    )               reduce using rule 38 (var -> name .)
    ,               reduce using rule 38 (var -> name .)


state 129

    (31) funcname -> funcname2 : name .
    STRING          reduce using rule 31 (funcname -> funcname2 : name .)
    (               reduce using rule 31 (funcname -> funcname2 : name .)
    {               reduce using rule 31 (funcname -> funcname2 : name .)


state 130

    (32) funcname2 -> funcname2 . name .
    :               reduce using rule 32 (funcname2 -> funcname2 . name .)
    .               reduce using rule 32 (funcname2 -> funcname2 . name .)
    STRING          reduce using rule 32 (funcname2 -> funcname2 . name .)
    (               reduce using rule 32 (funcname2 -> funcname2 . name .)
    {               reduce using rule 32 (funcname2 -> funcname2 . name .)


state 131

    (12) stat -> FOR namelist IN explist . DO block END
    (43) explist -> explist . , exp
    DO              shift and go to state 169
    ,               shift and go to state 119


state 132

    (13) stat -> FOR name = exp . , exp , exp DO block END
    (14) stat -> FOR name = exp . , exp DO block END
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    ,               shift and go to state 170
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 133

    (15) stat -> IF exp THEN block . elseiflist _else END
    (21) elseiflist -> . empty
    (22) elseiflist -> . elseiflist elseif
    (23) elseiflist -> . elseif
    (100) empty -> .
    (24) elseif -> . ELSEIF exp THEN block
  ! shift/reduce conflict for ELSEIF resolved as shift
    ELSE            reduce using rule 100 (empty -> .)
    END             reduce using rule 100 (empty -> .)
    ELSEIF          shift and go to state 174

    elseiflist                     shift and go to state 171
    empty                          shift and go to state 172
    elseif                         shift and go to state 173

state 134

    (48) exp -> exp OR exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 48 (exp -> exp OR exp .)
    OR              reduce using rule 48 (exp -> exp OR exp .)
    )               reduce using rule 48 (exp -> exp OR exp .)
    ,               reduce using rule 48 (exp -> exp OR exp .)
    $end            reduce using rule 48 (exp -> exp OR exp .)
    UNTIL           reduce using rule 48 (exp -> exp OR exp .)
    ELSEIF          reduce using rule 48 (exp -> exp OR exp .)
    ELSE            reduce using rule 48 (exp -> exp OR exp .)
    END             reduce using rule 48 (exp -> exp OR exp .)
    {               reduce using rule 48 (exp -> exp OR exp .)
    ;               reduce using rule 48 (exp -> exp OR exp .)
    }               reduce using rule 48 (exp -> exp OR exp .)
    BREAK           reduce using rule 48 (exp -> exp OR exp .)
    RETURN          reduce using rule 48 (exp -> exp OR exp .)
    LOCAL           reduce using rule 48 (exp -> exp OR exp .)
    FUNCTION        reduce using rule 48 (exp -> exp OR exp .)
    FOR             reduce using rule 48 (exp -> exp OR exp .)
    IF              reduce using rule 48 (exp -> exp OR exp .)
    REPEAT          reduce using rule 48 (exp -> exp OR exp .)
    (               reduce using rule 48 (exp -> exp OR exp .)
    NAME            reduce using rule 48 (exp -> exp OR exp .)
    ]               reduce using rule 48 (exp -> exp OR exp .)
    DO              reduce using rule 48 (exp -> exp OR exp .)
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 135

    (49) exp -> exp AND exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 49 (exp -> exp AND exp .)
    OR              reduce using rule 49 (exp -> exp AND exp .)
    AND             reduce using rule 49 (exp -> exp AND exp .)
    )               reduce using rule 49 (exp -> exp AND exp .)
    ,               reduce using rule 49 (exp -> exp AND exp .)
    $end            reduce using rule 49 (exp -> exp AND exp .)
    UNTIL           reduce using rule 49 (exp -> exp AND exp .)
    ELSEIF          reduce using rule 49 (exp -> exp AND exp .)
    ELSE            reduce using rule 49 (exp -> exp AND exp .)
    END             reduce using rule 49 (exp -> exp AND exp .)
    {               reduce using rule 49 (exp -> exp AND exp .)
    ;               reduce using rule 49 (exp -> exp AND exp .)
    }               reduce using rule 49 (exp -> exp AND exp .)
    BREAK           reduce using rule 49 (exp -> exp AND exp .)
    RETURN          reduce using rule 49 (exp -> exp AND exp .)
    LOCAL           reduce using rule 49 (exp -> exp AND exp .)
    FUNCTION        reduce using rule 49 (exp -> exp AND exp .)
    FOR             reduce using rule 49 (exp -> exp AND exp .)
    IF              reduce using rule 49 (exp -> exp AND exp .)
    REPEAT          reduce using rule 49 (exp -> exp AND exp .)
    (               reduce using rule 49 (exp -> exp AND exp .)
    NAME            reduce using rule 49 (exp -> exp AND exp .)
    ]               reduce using rule 49 (exp -> exp AND exp .)
    DO              reduce using rule 49 (exp -> exp AND exp .)
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 136

    (50) exp -> exp NE exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 50 (exp -> exp NE exp .)
    OR              reduce using rule 50 (exp -> exp NE exp .)
    AND             reduce using rule 50 (exp -> exp NE exp .)
    NE              reduce using rule 50 (exp -> exp NE exp .)
    EQ              reduce using rule 50 (exp -> exp NE exp .)
    GE              reduce using rule 50 (exp -> exp NE exp .)
    GT              reduce using rule 50 (exp -> exp NE exp .)
    LE              reduce using rule 50 (exp -> exp NE exp .)
    LT              reduce using rule 50 (exp -> exp NE exp .)
    )               reduce using rule 50 (exp -> exp NE exp .)
    ,               reduce using rule 50 (exp -> exp NE exp .)
    $end            reduce using rule 50 (exp -> exp NE exp .)
    UNTIL           reduce using rule 50 (exp -> exp NE exp .)
    ELSEIF          reduce using rule 50 (exp -> exp NE exp .)
    ELSE            reduce using rule 50 (exp -> exp NE exp .)
    END             reduce using rule 50 (exp -> exp NE exp .)
    {               reduce using rule 50 (exp -> exp NE exp .)
    ;               reduce using rule 50 (exp -> exp NE exp .)
    }               reduce using rule 50 (exp -> exp NE exp .)
    BREAK           reduce using rule 50 (exp -> exp NE exp .)
    RETURN          reduce using rule 50 (exp -> exp NE exp .)
    LOCAL           reduce using rule 50 (exp -> exp NE exp .)
    FUNCTION        reduce using rule 50 (exp -> exp NE exp .)
    FOR             reduce using rule 50 (exp -> exp NE exp .)
    IF              reduce using rule 50 (exp -> exp NE exp .)
    REPEAT          reduce using rule 50 (exp -> exp NE exp .)
    (               reduce using rule 50 (exp -> exp NE exp .)
    NAME            reduce using rule 50 (exp -> exp NE exp .)
    ]               reduce using rule 50 (exp -> exp NE exp .)
    DO              reduce using rule 50 (exp -> exp NE exp .)
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 137

    (51) exp -> exp EQ exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 51 (exp -> exp EQ exp .)
    OR              reduce using rule 51 (exp -> exp EQ exp .)
    AND             reduce using rule 51 (exp -> exp EQ exp .)
    NE              reduce using rule 51 (exp -> exp EQ exp .)
    EQ              reduce using rule 51 (exp -> exp EQ exp .)
    GE              reduce using rule 51 (exp -> exp EQ exp .)
    GT              reduce using rule 51 (exp -> exp EQ exp .)
    LE              reduce using rule 51 (exp -> exp EQ exp .)
    LT              reduce using rule 51 (exp -> exp EQ exp .)
    )               reduce using rule 51 (exp -> exp EQ exp .)
    ,               reduce using rule 51 (exp -> exp EQ exp .)
    $end            reduce using rule 51 (exp -> exp EQ exp .)
    UNTIL           reduce using rule 51 (exp -> exp EQ exp .)
    ELSEIF          reduce using rule 51 (exp -> exp EQ exp .)
    ELSE            reduce using rule 51 (exp -> exp EQ exp .)
    END             reduce using rule 51 (exp -> exp EQ exp .)
    {               reduce using rule 51 (exp -> exp EQ exp .)
    ;               reduce using rule 51 (exp -> exp EQ exp .)
    }               reduce using rule 51 (exp -> exp EQ exp .)
    BREAK           reduce using rule 51 (exp -> exp EQ exp .)
    RETURN          reduce using rule 51 (exp -> exp EQ exp .)
    LOCAL           reduce using rule 51 (exp -> exp EQ exp .)
    FUNCTION        reduce using rule 51 (exp -> exp EQ exp .)
    FOR             reduce using rule 51 (exp -> exp EQ exp .)
    IF              reduce using rule 51 (exp -> exp EQ exp .)
    REPEAT          reduce using rule 51 (exp -> exp EQ exp .)
    (               reduce using rule 51 (exp -> exp EQ exp .)
    NAME            reduce using rule 51 (exp -> exp EQ exp .)
    ]               reduce using rule 51 (exp -> exp EQ exp .)
    DO              reduce using rule 51 (exp -> exp EQ exp .)
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 138

    (52) exp -> exp GE exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 52 (exp -> exp GE exp .)
    OR              reduce using rule 52 (exp -> exp GE exp .)
    AND             reduce using rule 52 (exp -> exp GE exp .)
    NE              reduce using rule 52 (exp -> exp GE exp .)
    EQ              reduce using rule 52 (exp -> exp GE exp .)
    GE              reduce using rule 52 (exp -> exp GE exp .)
    GT              reduce using rule 52 (exp -> exp GE exp .)
    LE              reduce using rule 52 (exp -> exp GE exp .)
    LT              reduce using rule 52 (exp -> exp GE exp .)
    )               reduce using rule 52 (exp -> exp GE exp .)
    ,               reduce using rule 52 (exp -> exp GE exp .)
    $end            reduce using rule 52 (exp -> exp GE exp .)
    UNTIL           reduce using rule 52 (exp -> exp GE exp .)
    ELSEIF          reduce using rule 52 (exp -> exp GE exp .)
    ELSE            reduce using rule 52 (exp -> exp GE exp .)
    END             reduce using rule 52 (exp -> exp GE exp .)
    {               reduce using rule 52 (exp -> exp GE exp .)
    ;               reduce using rule 52 (exp -> exp GE exp .)
    }               reduce using rule 52 (exp -> exp GE exp .)
    BREAK           reduce using rule 52 (exp -> exp GE exp .)
    RETURN          reduce using rule 52 (exp -> exp GE exp .)
    LOCAL           reduce using rule 52 (exp -> exp GE exp .)
    FUNCTION        reduce using rule 52 (exp -> exp GE exp .)
    FOR             reduce using rule 52 (exp -> exp GE exp .)
    IF              reduce using rule 52 (exp -> exp GE exp .)
    REPEAT          reduce using rule 52 (exp -> exp GE exp .)
    (               reduce using rule 52 (exp -> exp GE exp .)
    NAME            reduce using rule 52 (exp -> exp GE exp .)
    ]               reduce using rule 52 (exp -> exp GE exp .)
    DO              reduce using rule 52 (exp -> exp GE exp .)
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 139

    (53) exp -> exp GT exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 53 (exp -> exp GT exp .)
    OR              reduce using rule 53 (exp -> exp GT exp .)
    AND             reduce using rule 53 (exp -> exp GT exp .)
    NE              reduce using rule 53 (exp -> exp GT exp .)
    EQ              reduce using rule 53 (exp -> exp GT exp .)
    GE              reduce using rule 53 (exp -> exp GT exp .)
    GT              reduce using rule 53 (exp -> exp GT exp .)
    LE              reduce using rule 53 (exp -> exp GT exp .)
    LT              reduce using rule 53 (exp -> exp GT exp .)
    )               reduce using rule 53 (exp -> exp GT exp .)
    ,               reduce using rule 53 (exp -> exp GT exp .)
    $end            reduce using rule 53 (exp -> exp GT exp .)
    UNTIL           reduce using rule 53 (exp -> exp GT exp .)
    ELSEIF          reduce using rule 53 (exp -> exp GT exp .)
    ELSE            reduce using rule 53 (exp -> exp GT exp .)
    END             reduce using rule 53 (exp -> exp GT exp .)
    {               reduce using rule 53 (exp -> exp GT exp .)
    ;               reduce using rule 53 (exp -> exp GT exp .)
    }               reduce using rule 53 (exp -> exp GT exp .)
    BREAK           reduce using rule 53 (exp -> exp GT exp .)
    RETURN          reduce using rule 53 (exp -> exp GT exp .)
    LOCAL           reduce using rule 53 (exp -> exp GT exp .)
    FUNCTION        reduce using rule 53 (exp -> exp GT exp .)
    FOR             reduce using rule 53 (exp -> exp GT exp .)
    IF              reduce using rule 53 (exp -> exp GT exp .)
    REPEAT          reduce using rule 53 (exp -> exp GT exp .)
    (               reduce using rule 53 (exp -> exp GT exp .)
    NAME            reduce using rule 53 (exp -> exp GT exp .)
    ]               reduce using rule 53 (exp -> exp GT exp .)
    DO              reduce using rule 53 (exp -> exp GT exp .)
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 140

    (54) exp -> exp LE exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 54 (exp -> exp LE exp .)
    OR              reduce using rule 54 (exp -> exp LE exp .)
    AND             reduce using rule 54 (exp -> exp LE exp .)
    NE              reduce using rule 54 (exp -> exp LE exp .)
    EQ              reduce using rule 54 (exp -> exp LE exp .)
    GE              reduce using rule 54 (exp -> exp LE exp .)
    GT              reduce using rule 54 (exp -> exp LE exp .)
    LE              reduce using rule 54 (exp -> exp LE exp .)
    LT              reduce using rule 54 (exp -> exp LE exp .)
    )               reduce using rule 54 (exp -> exp LE exp .)
    ,               reduce using rule 54 (exp -> exp LE exp .)
    $end            reduce using rule 54 (exp -> exp LE exp .)
    UNTIL           reduce using rule 54 (exp -> exp LE exp .)
    ELSEIF          reduce using rule 54 (exp -> exp LE exp .)
    ELSE            reduce using rule 54 (exp -> exp LE exp .)
    END             reduce using rule 54 (exp -> exp LE exp .)
    {               reduce using rule 54 (exp -> exp LE exp .)
    ;               reduce using rule 54 (exp -> exp LE exp .)
    }               reduce using rule 54 (exp -> exp LE exp .)
    BREAK           reduce using rule 54 (exp -> exp LE exp .)
    RETURN          reduce using rule 54 (exp -> exp LE exp .)
    LOCAL           reduce using rule 54 (exp -> exp LE exp .)
    FUNCTION        reduce using rule 54 (exp -> exp LE exp .)
    FOR             reduce using rule 54 (exp -> exp LE exp .)
    IF              reduce using rule 54 (exp -> exp LE exp .)
    REPEAT          reduce using rule 54 (exp -> exp LE exp .)
    (               reduce using rule 54 (exp -> exp LE exp .)
    NAME            reduce using rule 54 (exp -> exp LE exp .)
    ]               reduce using rule 54 (exp -> exp LE exp .)
    DO              reduce using rule 54 (exp -> exp LE exp .)
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 141

    (55) exp -> exp LT exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 55 (exp -> exp LT exp .)
    OR              reduce using rule 55 (exp -> exp LT exp .)
    AND             reduce using rule 55 (exp -> exp LT exp .)
    NE              reduce using rule 55 (exp -> exp LT exp .)
    EQ              reduce using rule 55 (exp -> exp LT exp .)
    GE              reduce using rule 55 (exp -> exp LT exp .)
    GT              reduce using rule 55 (exp -> exp LT exp .)
    LE              reduce using rule 55 (exp -> exp LT exp .)
    LT              reduce using rule 55 (exp -> exp LT exp .)
    )               reduce using rule 55 (exp -> exp LT exp .)
    ,               reduce using rule 55 (exp -> exp LT exp .)
    $end            reduce using rule 55 (exp -> exp LT exp .)
    UNTIL           reduce using rule 55 (exp -> exp LT exp .)
    ELSEIF          reduce using rule 55 (exp -> exp LT exp .)
    ELSE            reduce using rule 55 (exp -> exp LT exp .)
    END             reduce using rule 55 (exp -> exp LT exp .)
    {               reduce using rule 55 (exp -> exp LT exp .)
    ;               reduce using rule 55 (exp -> exp LT exp .)
    }               reduce using rule 55 (exp -> exp LT exp .)
    BREAK           reduce using rule 55 (exp -> exp LT exp .)
    RETURN          reduce using rule 55 (exp -> exp LT exp .)
    LOCAL           reduce using rule 55 (exp -> exp LT exp .)
    FUNCTION        reduce using rule 55 (exp -> exp LT exp .)
    FOR             reduce using rule 55 (exp -> exp LT exp .)
    IF              reduce using rule 55 (exp -> exp LT exp .)
    REPEAT          reduce using rule 55 (exp -> exp LT exp .)
    (               reduce using rule 55 (exp -> exp LT exp .)
    NAME            reduce using rule 55 (exp -> exp LT exp .)
    ]               reduce using rule 55 (exp -> exp LT exp .)
    DO              reduce using rule 55 (exp -> exp LT exp .)
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 142

    (56) exp -> exp CONCAT exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 56 (exp -> exp CONCAT exp .)
    OR              reduce using rule 56 (exp -> exp CONCAT exp .)
    AND             reduce using rule 56 (exp -> exp CONCAT exp .)
    NE              reduce using rule 56 (exp -> exp CONCAT exp .)
    EQ              reduce using rule 56 (exp -> exp CONCAT exp .)
    GE              reduce using rule 56 (exp -> exp CONCAT exp .)
    GT              reduce using rule 56 (exp -> exp CONCAT exp .)
    LE              reduce using rule 56 (exp -> exp CONCAT exp .)
    LT              reduce using rule 56 (exp -> exp CONCAT exp .)
    )               reduce using rule 56 (exp -> exp CONCAT exp .)
    ,               reduce using rule 56 (exp -> exp CONCAT exp .)
    $end            reduce using rule 56 (exp -> exp CONCAT exp .)
    UNTIL           reduce using rule 56 (exp -> exp CONCAT exp .)
    ELSEIF          reduce using rule 56 (exp -> exp CONCAT exp .)
    ELSE            reduce using rule 56 (exp -> exp CONCAT exp .)
    END             reduce using rule 56 (exp -> exp CONCAT exp .)
    {               reduce using rule 56 (exp -> exp CONCAT exp .)
    ;               reduce using rule 56 (exp -> exp CONCAT exp .)
    }               reduce using rule 56 (exp -> exp CONCAT exp .)
    BREAK           reduce using rule 56 (exp -> exp CONCAT exp .)
    RETURN          reduce using rule 56 (exp -> exp CONCAT exp .)
    LOCAL           reduce using rule 56 (exp -> exp CONCAT exp .)
    FUNCTION        reduce using rule 56 (exp -> exp CONCAT exp .)
    FOR             reduce using rule 56 (exp -> exp CONCAT exp .)
    IF              reduce using rule 56 (exp -> exp CONCAT exp .)
    REPEAT          reduce using rule 56 (exp -> exp CONCAT exp .)
    (               reduce using rule 56 (exp -> exp CONCAT exp .)
    NAME            reduce using rule 56 (exp -> exp CONCAT exp .)
    ]               reduce using rule 56 (exp -> exp CONCAT exp .)
    DO              reduce using rule 56 (exp -> exp CONCAT exp .)
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 143

    (57) exp -> exp % exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 57 (exp -> exp % exp .)
    OR              reduce using rule 57 (exp -> exp % exp .)
    AND             reduce using rule 57 (exp -> exp % exp .)
    NE              reduce using rule 57 (exp -> exp % exp .)
    EQ              reduce using rule 57 (exp -> exp % exp .)
    GE              reduce using rule 57 (exp -> exp % exp .)
    GT              reduce using rule 57 (exp -> exp % exp .)
    LE              reduce using rule 57 (exp -> exp % exp .)
    LT              reduce using rule 57 (exp -> exp % exp .)
    CONCAT          reduce using rule 57 (exp -> exp % exp .)
    %               reduce using rule 57 (exp -> exp % exp .)
    /               reduce using rule 57 (exp -> exp % exp .)
    *               reduce using rule 57 (exp -> exp % exp .)
    -               reduce using rule 57 (exp -> exp % exp .)
    +               reduce using rule 57 (exp -> exp % exp .)
    )               reduce using rule 57 (exp -> exp % exp .)
    ,               reduce using rule 57 (exp -> exp % exp .)
    $end            reduce using rule 57 (exp -> exp % exp .)
    UNTIL           reduce using rule 57 (exp -> exp % exp .)
    ELSEIF          reduce using rule 57 (exp -> exp % exp .)
    ELSE            reduce using rule 57 (exp -> exp % exp .)
    END             reduce using rule 57 (exp -> exp % exp .)
    {               reduce using rule 57 (exp -> exp % exp .)
    ;               reduce using rule 57 (exp -> exp % exp .)
    }               reduce using rule 57 (exp -> exp % exp .)
    BREAK           reduce using rule 57 (exp -> exp % exp .)
    RETURN          reduce using rule 57 (exp -> exp % exp .)
    LOCAL           reduce using rule 57 (exp -> exp % exp .)
    FUNCTION        reduce using rule 57 (exp -> exp % exp .)
    FOR             reduce using rule 57 (exp -> exp % exp .)
    IF              reduce using rule 57 (exp -> exp % exp .)
    REPEAT          reduce using rule 57 (exp -> exp % exp .)
    (               reduce using rule 57 (exp -> exp % exp .)
    NAME            reduce using rule 57 (exp -> exp % exp .)
    ]               reduce using rule 57 (exp -> exp % exp .)
    DO              reduce using rule 57 (exp -> exp % exp .)
    ^               shift and go to state 90


state 144

    (58) exp -> exp ^ exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 58 (exp -> exp ^ exp .)
    OR              reduce using rule 58 (exp -> exp ^ exp .)
    AND             reduce using rule 58 (exp -> exp ^ exp .)
    NE              reduce using rule 58 (exp -> exp ^ exp .)
    EQ              reduce using rule 58 (exp -> exp ^ exp .)
    GE              reduce using rule 58 (exp -> exp ^ exp .)
    GT              reduce using rule 58 (exp -> exp ^ exp .)
    LE              reduce using rule 58 (exp -> exp ^ exp .)
    LT              reduce using rule 58 (exp -> exp ^ exp .)
    CONCAT          reduce using rule 58 (exp -> exp ^ exp .)
    %               reduce using rule 58 (exp -> exp ^ exp .)
    /               reduce using rule 58 (exp -> exp ^ exp .)
    *               reduce using rule 58 (exp -> exp ^ exp .)
    -               reduce using rule 58 (exp -> exp ^ exp .)
    +               reduce using rule 58 (exp -> exp ^ exp .)
    )               reduce using rule 58 (exp -> exp ^ exp .)
    ,               reduce using rule 58 (exp -> exp ^ exp .)
    $end            reduce using rule 58 (exp -> exp ^ exp .)
    UNTIL           reduce using rule 58 (exp -> exp ^ exp .)
    ELSEIF          reduce using rule 58 (exp -> exp ^ exp .)
    ELSE            reduce using rule 58 (exp -> exp ^ exp .)
    END             reduce using rule 58 (exp -> exp ^ exp .)
    {               reduce using rule 58 (exp -> exp ^ exp .)
    ;               reduce using rule 58 (exp -> exp ^ exp .)
    }               reduce using rule 58 (exp -> exp ^ exp .)
    BREAK           reduce using rule 58 (exp -> exp ^ exp .)
    RETURN          reduce using rule 58 (exp -> exp ^ exp .)
    LOCAL           reduce using rule 58 (exp -> exp ^ exp .)
    FUNCTION        reduce using rule 58 (exp -> exp ^ exp .)
    FOR             reduce using rule 58 (exp -> exp ^ exp .)
    IF              reduce using rule 58 (exp -> exp ^ exp .)
    REPEAT          reduce using rule 58 (exp -> exp ^ exp .)
    (               reduce using rule 58 (exp -> exp ^ exp .)
    NAME            reduce using rule 58 (exp -> exp ^ exp .)
    ]               reduce using rule 58 (exp -> exp ^ exp .)
    DO              reduce using rule 58 (exp -> exp ^ exp .)
    ^               shift and go to state 90


state 145

    (59) exp -> exp / exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 59 (exp -> exp / exp .)
    OR              reduce using rule 59 (exp -> exp / exp .)
    AND             reduce using rule 59 (exp -> exp / exp .)
    NE              reduce using rule 59 (exp -> exp / exp .)
    EQ              reduce using rule 59 (exp -> exp / exp .)
    GE              reduce using rule 59 (exp -> exp / exp .)
    GT              reduce using rule 59 (exp -> exp / exp .)
    LE              reduce using rule 59 (exp -> exp / exp .)
    LT              reduce using rule 59 (exp -> exp / exp .)
    CONCAT          reduce using rule 59 (exp -> exp / exp .)
    %               reduce using rule 59 (exp -> exp / exp .)
    /               reduce using rule 59 (exp -> exp / exp .)
    *               reduce using rule 59 (exp -> exp / exp .)
    -               reduce using rule 59 (exp -> exp / exp .)
    +               reduce using rule 59 (exp -> exp / exp .)
    )               reduce using rule 59 (exp -> exp / exp .)
    ,               reduce using rule 59 (exp -> exp / exp .)
    $end            reduce using rule 59 (exp -> exp / exp .)
    UNTIL           reduce using rule 59 (exp -> exp / exp .)
    ELSEIF          reduce using rule 59 (exp -> exp / exp .)
    ELSE            reduce using rule 59 (exp -> exp / exp .)
    END             reduce using rule 59 (exp -> exp / exp .)
    {               reduce using rule 59 (exp -> exp / exp .)
    ;               reduce using rule 59 (exp -> exp / exp .)
    }               reduce using rule 59 (exp -> exp / exp .)
    BREAK           reduce using rule 59 (exp -> exp / exp .)
    RETURN          reduce using rule 59 (exp -> exp / exp .)
    LOCAL           reduce using rule 59 (exp -> exp / exp .)
    FUNCTION        reduce using rule 59 (exp -> exp / exp .)
    FOR             reduce using rule 59 (exp -> exp / exp .)
    IF              reduce using rule 59 (exp -> exp / exp .)
    REPEAT          reduce using rule 59 (exp -> exp / exp .)
    (               reduce using rule 59 (exp -> exp / exp .)
    NAME            reduce using rule 59 (exp -> exp / exp .)
    ]               reduce using rule 59 (exp -> exp / exp .)
    DO              reduce using rule 59 (exp -> exp / exp .)
    ^               shift and go to state 90


state 146

    (60) exp -> exp * exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 60 (exp -> exp * exp .)
    OR              reduce using rule 60 (exp -> exp * exp .)
    AND             reduce using rule 60 (exp -> exp * exp .)
    NE              reduce using rule 60 (exp -> exp * exp .)
    EQ              reduce using rule 60 (exp -> exp * exp .)
    GE              reduce using rule 60 (exp -> exp * exp .)
    GT              reduce using rule 60 (exp -> exp * exp .)
    LE              reduce using rule 60 (exp -> exp * exp .)
    LT              reduce using rule 60 (exp -> exp * exp .)
    CONCAT          reduce using rule 60 (exp -> exp * exp .)
    %               reduce using rule 60 (exp -> exp * exp .)
    /               reduce using rule 60 (exp -> exp * exp .)
    *               reduce using rule 60 (exp -> exp * exp .)
    -               reduce using rule 60 (exp -> exp * exp .)
    +               reduce using rule 60 (exp -> exp * exp .)
    )               reduce using rule 60 (exp -> exp * exp .)
    ,               reduce using rule 60 (exp -> exp * exp .)
    $end            reduce using rule 60 (exp -> exp * exp .)
    UNTIL           reduce using rule 60 (exp -> exp * exp .)
    ELSEIF          reduce using rule 60 (exp -> exp * exp .)
    ELSE            reduce using rule 60 (exp -> exp * exp .)
    END             reduce using rule 60 (exp -> exp * exp .)
    {               reduce using rule 60 (exp -> exp * exp .)
    ;               reduce using rule 60 (exp -> exp * exp .)
    }               reduce using rule 60 (exp -> exp * exp .)
    BREAK           reduce using rule 60 (exp -> exp * exp .)
    RETURN          reduce using rule 60 (exp -> exp * exp .)
    LOCAL           reduce using rule 60 (exp -> exp * exp .)
    FUNCTION        reduce using rule 60 (exp -> exp * exp .)
    FOR             reduce using rule 60 (exp -> exp * exp .)
    IF              reduce using rule 60 (exp -> exp * exp .)
    REPEAT          reduce using rule 60 (exp -> exp * exp .)
    (               reduce using rule 60 (exp -> exp * exp .)
    NAME            reduce using rule 60 (exp -> exp * exp .)
    ]               reduce using rule 60 (exp -> exp * exp .)
    DO              reduce using rule 60 (exp -> exp * exp .)
    ^               shift and go to state 90


state 147

    (61) exp -> exp - exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 61 (exp -> exp - exp .)
    OR              reduce using rule 61 (exp -> exp - exp .)
    AND             reduce using rule 61 (exp -> exp - exp .)
    NE              reduce using rule 61 (exp -> exp - exp .)
    EQ              reduce using rule 61 (exp -> exp - exp .)
    GE              reduce using rule 61 (exp -> exp - exp .)
    GT              reduce using rule 61 (exp -> exp - exp .)
    LE              reduce using rule 61 (exp -> exp - exp .)
    LT              reduce using rule 61 (exp -> exp - exp .)
    CONCAT          reduce using rule 61 (exp -> exp - exp .)
    -               reduce using rule 61 (exp -> exp - exp .)
    +               reduce using rule 61 (exp -> exp - exp .)
    )               reduce using rule 61 (exp -> exp - exp .)
    ,               reduce using rule 61 (exp -> exp - exp .)
    $end            reduce using rule 61 (exp -> exp - exp .)
    UNTIL           reduce using rule 61 (exp -> exp - exp .)
    ELSEIF          reduce using rule 61 (exp -> exp - exp .)
    ELSE            reduce using rule 61 (exp -> exp - exp .)
    END             reduce using rule 61 (exp -> exp - exp .)
    {               reduce using rule 61 (exp -> exp - exp .)
    ;               reduce using rule 61 (exp -> exp - exp .)
    }               reduce using rule 61 (exp -> exp - exp .)
    BREAK           reduce using rule 61 (exp -> exp - exp .)
    RETURN          reduce using rule 61 (exp -> exp - exp .)
    LOCAL           reduce using rule 61 (exp -> exp - exp .)
    FUNCTION        reduce using rule 61 (exp -> exp - exp .)
    FOR             reduce using rule 61 (exp -> exp - exp .)
    IF              reduce using rule 61 (exp -> exp - exp .)
    REPEAT          reduce using rule 61 (exp -> exp - exp .)
    (               reduce using rule 61 (exp -> exp - exp .)
    NAME            reduce using rule 61 (exp -> exp - exp .)
    ]               reduce using rule 61 (exp -> exp - exp .)
    DO              reduce using rule 61 (exp -> exp - exp .)
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92


state 148

    (62) exp -> exp + exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            reduce using rule 62 (exp -> exp + exp .)
    OR              reduce using rule 62 (exp -> exp + exp .)
    AND             reduce using rule 62 (exp -> exp + exp .)
    NE              reduce using rule 62 (exp -> exp + exp .)
    EQ              reduce using rule 62 (exp -> exp + exp .)
    GE              reduce using rule 62 (exp -> exp + exp .)
    GT              reduce using rule 62 (exp -> exp + exp .)
    LE              reduce using rule 62 (exp -> exp + exp .)
    LT              reduce using rule 62 (exp -> exp + exp .)
    CONCAT          reduce using rule 62 (exp -> exp + exp .)
    -               reduce using rule 62 (exp -> exp + exp .)
    +               reduce using rule 62 (exp -> exp + exp .)
    )               reduce using rule 62 (exp -> exp + exp .)
    ,               reduce using rule 62 (exp -> exp + exp .)
    $end            reduce using rule 62 (exp -> exp + exp .)
    UNTIL           reduce using rule 62 (exp -> exp + exp .)
    ELSEIF          reduce using rule 62 (exp -> exp + exp .)
    ELSE            reduce using rule 62 (exp -> exp + exp .)
    END             reduce using rule 62 (exp -> exp + exp .)
    {               reduce using rule 62 (exp -> exp + exp .)
    ;               reduce using rule 62 (exp -> exp + exp .)
    }               reduce using rule 62 (exp -> exp + exp .)
    BREAK           reduce using rule 62 (exp -> exp + exp .)
    RETURN          reduce using rule 62 (exp -> exp + exp .)
    LOCAL           reduce using rule 62 (exp -> exp + exp .)
    FUNCTION        reduce using rule 62 (exp -> exp + exp .)
    FOR             reduce using rule 62 (exp -> exp + exp .)
    IF              reduce using rule 62 (exp -> exp + exp .)
    REPEAT          reduce using rule 62 (exp -> exp + exp .)
    (               reduce using rule 62 (exp -> exp + exp .)
    NAME            reduce using rule 62 (exp -> exp + exp .)
    ]               reduce using rule 62 (exp -> exp + exp .)
    DO              reduce using rule 62 (exp -> exp + exp .)
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92


state 149

    (89) tableconstructor -> { fieldlist } .
    THEN            reduce using rule 89 (tableconstructor -> { fieldlist } .)
    OR              reduce using rule 89 (tableconstructor -> { fieldlist } .)
    AND             reduce using rule 89 (tableconstructor -> { fieldlist } .)
    NE              reduce using rule 89 (tableconstructor -> { fieldlist } .)
    EQ              reduce using rule 89 (tableconstructor -> { fieldlist } .)
    GE              reduce using rule 89 (tableconstructor -> { fieldlist } .)
    GT              reduce using rule 89 (tableconstructor -> { fieldlist } .)
    LE              reduce using rule 89 (tableconstructor -> { fieldlist } .)
    LT              reduce using rule 89 (tableconstructor -> { fieldlist } .)
    CONCAT          reduce using rule 89 (tableconstructor -> { fieldlist } .)
    %               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    ^               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    /               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    *               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    -               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    +               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    ;               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    BREAK           reduce using rule 89 (tableconstructor -> { fieldlist } .)
    RETURN          reduce using rule 89 (tableconstructor -> { fieldlist } .)
    LOCAL           reduce using rule 89 (tableconstructor -> { fieldlist } .)
    FUNCTION        reduce using rule 89 (tableconstructor -> { fieldlist } .)
    FOR             reduce using rule 89 (tableconstructor -> { fieldlist } .)
    IF              reduce using rule 89 (tableconstructor -> { fieldlist } .)
    REPEAT          reduce using rule 89 (tableconstructor -> { fieldlist } .)
    {               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    (               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    NAME            reduce using rule 89 (tableconstructor -> { fieldlist } .)
    :               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    .               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    [               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    STRING          reduce using rule 89 (tableconstructor -> { fieldlist } .)
    )               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    ,               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    $end            reduce using rule 89 (tableconstructor -> { fieldlist } .)
    UNTIL           reduce using rule 89 (tableconstructor -> { fieldlist } .)
    ELSEIF          reduce using rule 89 (tableconstructor -> { fieldlist } .)
    ELSE            reduce using rule 89 (tableconstructor -> { fieldlist } .)
    END             reduce using rule 89 (tableconstructor -> { fieldlist } .)
    }               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    ]               reduce using rule 89 (tableconstructor -> { fieldlist } .)
    DO              reduce using rule 89 (tableconstructor -> { fieldlist } .)


state 150

    (90) fieldlist -> fieldlist2 optfieldsep .
    }               reduce using rule 90 (fieldlist -> fieldlist2 optfieldsep .)


state 151

    (91) fieldlist2 -> fieldlist2 fieldsep . field
    (97) optfieldsep -> fieldsep .
    (93) field -> . exp
    (94) field -> . NAME = exp
    (95) field -> . [ exp ] = exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    }               reduce using rule 97 (optfieldsep -> fieldsep .)
    NAME            shift and go to state 103
    [               shift and go to state 104
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49

    field                          shift and go to state 175
    exp                            shift and go to state 102
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 152

    (96) optfieldsep -> empty .
    }               reduce using rule 96 (optfieldsep -> empty .)


state 153

    (98) fieldsep -> ; .
    NAME            reduce using rule 98 (fieldsep -> ; .)
    [               reduce using rule 98 (fieldsep -> ; .)
    #               reduce using rule 98 (fieldsep -> ; .)
    NOT             reduce using rule 98 (fieldsep -> ; .)
    -               reduce using rule 98 (fieldsep -> ; .)
    VARARG          reduce using rule 98 (fieldsep -> ; .)
    NIL             reduce using rule 98 (fieldsep -> ; .)
    NUMBER          reduce using rule 98 (fieldsep -> ; .)
    STRING          reduce using rule 98 (fieldsep -> ; .)
    TRUE            reduce using rule 98 (fieldsep -> ; .)
    FALSE           reduce using rule 98 (fieldsep -> ; .)
    {               reduce using rule 98 (fieldsep -> ; .)
    (               reduce using rule 98 (fieldsep -> ; .)
    FUNCTION        reduce using rule 98 (fieldsep -> ; .)
    }               reduce using rule 98 (fieldsep -> ; .)


state 154

    (99) fieldsep -> , .
    NAME            reduce using rule 99 (fieldsep -> , .)
    [               reduce using rule 99 (fieldsep -> , .)
    #               reduce using rule 99 (fieldsep -> , .)
    NOT             reduce using rule 99 (fieldsep -> , .)
    -               reduce using rule 99 (fieldsep -> , .)
    VARARG          reduce using rule 99 (fieldsep -> , .)
    NIL             reduce using rule 99 (fieldsep -> , .)
    NUMBER          reduce using rule 99 (fieldsep -> , .)
    STRING          reduce using rule 99 (fieldsep -> , .)
    TRUE            reduce using rule 99 (fieldsep -> , .)
    FALSE           reduce using rule 99 (fieldsep -> , .)
    {               reduce using rule 99 (fieldsep -> , .)
    (               reduce using rule 99 (fieldsep -> , .)
    FUNCTION        reduce using rule 99 (fieldsep -> , .)
    }               reduce using rule 99 (fieldsep -> , .)


state 155

    (94) field -> NAME = . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 176
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 156

    (95) field -> [ exp . ] = exp
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    ]               shift and go to state 177
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 157

    (82) funcbody -> ( ) . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 166
    chunk                          shift and go to state 51
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 158

    (84) parlist -> VARARG .
    )               reduce using rule 84 (parlist -> VARARG .)


state 159

    (16) stat -> REPEAT block UNTIL exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    ;               reduce using rule 16 (stat -> REPEAT block UNTIL exp .)
    BREAK           reduce using rule 16 (stat -> REPEAT block UNTIL exp .)
    RETURN          reduce using rule 16 (stat -> REPEAT block UNTIL exp .)
    LOCAL           reduce using rule 16 (stat -> REPEAT block UNTIL exp .)
    FUNCTION        reduce using rule 16 (stat -> REPEAT block UNTIL exp .)
    FOR             reduce using rule 16 (stat -> REPEAT block UNTIL exp .)
    IF              reduce using rule 16 (stat -> REPEAT block UNTIL exp .)
    REPEAT          reduce using rule 16 (stat -> REPEAT block UNTIL exp .)
    {               reduce using rule 16 (stat -> REPEAT block UNTIL exp .)
    (               reduce using rule 16 (stat -> REPEAT block UNTIL exp .)
    NAME            reduce using rule 16 (stat -> REPEAT block UNTIL exp .)
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 160

    (17) stat -> { WHILE } exp . { DO } block { END }
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    {               shift and go to state 178
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 161

    (18) stat -> { DO } block . { END }
    {               shift and go to state 179


state 162

    (75) functioncall -> prefixexp : name args .
    ;               reduce using rule 75 (functioncall -> prefixexp : name args .)
    BREAK           reduce using rule 75 (functioncall -> prefixexp : name args .)
    RETURN          reduce using rule 75 (functioncall -> prefixexp : name args .)
    LOCAL           reduce using rule 75 (functioncall -> prefixexp : name args .)
    FUNCTION        reduce using rule 75 (functioncall -> prefixexp : name args .)
    FOR             reduce using rule 75 (functioncall -> prefixexp : name args .)
    IF              reduce using rule 75 (functioncall -> prefixexp : name args .)
    REPEAT          reduce using rule 75 (functioncall -> prefixexp : name args .)
    {               reduce using rule 75 (functioncall -> prefixexp : name args .)
    (               reduce using rule 75 (functioncall -> prefixexp : name args .)
    NAME            reduce using rule 75 (functioncall -> prefixexp : name args .)
    :               reduce using rule 75 (functioncall -> prefixexp : name args .)
    .               reduce using rule 75 (functioncall -> prefixexp : name args .)
    [               reduce using rule 75 (functioncall -> prefixexp : name args .)
    STRING          reduce using rule 75 (functioncall -> prefixexp : name args .)
    THEN            reduce using rule 75 (functioncall -> prefixexp : name args .)
    OR              reduce using rule 75 (functioncall -> prefixexp : name args .)
    AND             reduce using rule 75 (functioncall -> prefixexp : name args .)
    NE              reduce using rule 75 (functioncall -> prefixexp : name args .)
    EQ              reduce using rule 75 (functioncall -> prefixexp : name args .)
    GE              reduce using rule 75 (functioncall -> prefixexp : name args .)
    GT              reduce using rule 75 (functioncall -> prefixexp : name args .)
    LE              reduce using rule 75 (functioncall -> prefixexp : name args .)
    LT              reduce using rule 75 (functioncall -> prefixexp : name args .)
    CONCAT          reduce using rule 75 (functioncall -> prefixexp : name args .)
    %               reduce using rule 75 (functioncall -> prefixexp : name args .)
    ^               reduce using rule 75 (functioncall -> prefixexp : name args .)
    /               reduce using rule 75 (functioncall -> prefixexp : name args .)
    *               reduce using rule 75 (functioncall -> prefixexp : name args .)
    -               reduce using rule 75 (functioncall -> prefixexp : name args .)
    +               reduce using rule 75 (functioncall -> prefixexp : name args .)
    )               reduce using rule 75 (functioncall -> prefixexp : name args .)
    ,               reduce using rule 75 (functioncall -> prefixexp : name args .)
    $end            reduce using rule 75 (functioncall -> prefixexp : name args .)
    UNTIL           reduce using rule 75 (functioncall -> prefixexp : name args .)
    ELSEIF          reduce using rule 75 (functioncall -> prefixexp : name args .)
    ELSE            reduce using rule 75 (functioncall -> prefixexp : name args .)
    END             reduce using rule 75 (functioncall -> prefixexp : name args .)
    }               reduce using rule 75 (functioncall -> prefixexp : name args .)
    ]               reduce using rule 75 (functioncall -> prefixexp : name args .)
    DO              reduce using rule 75 (functioncall -> prefixexp : name args .)


state 163

    (37) var -> prefixexp [ exp ] .
    :               reduce using rule 37 (var -> prefixexp [ exp ] .)
    .               reduce using rule 37 (var -> prefixexp [ exp ] .)
    [               reduce using rule 37 (var -> prefixexp [ exp ] .)
    STRING          reduce using rule 37 (var -> prefixexp [ exp ] .)
    (               reduce using rule 37 (var -> prefixexp [ exp ] .)
    {               reduce using rule 37 (var -> prefixexp [ exp ] .)
    ,               reduce using rule 37 (var -> prefixexp [ exp ] .)
    =               reduce using rule 37 (var -> prefixexp [ exp ] .)
    THEN            reduce using rule 37 (var -> prefixexp [ exp ] .)
    OR              reduce using rule 37 (var -> prefixexp [ exp ] .)
    AND             reduce using rule 37 (var -> prefixexp [ exp ] .)
    NE              reduce using rule 37 (var -> prefixexp [ exp ] .)
    EQ              reduce using rule 37 (var -> prefixexp [ exp ] .)
    GE              reduce using rule 37 (var -> prefixexp [ exp ] .)
    GT              reduce using rule 37 (var -> prefixexp [ exp ] .)
    LE              reduce using rule 37 (var -> prefixexp [ exp ] .)
    LT              reduce using rule 37 (var -> prefixexp [ exp ] .)
    CONCAT          reduce using rule 37 (var -> prefixexp [ exp ] .)
    %               reduce using rule 37 (var -> prefixexp [ exp ] .)
    ^               reduce using rule 37 (var -> prefixexp [ exp ] .)
    /               reduce using rule 37 (var -> prefixexp [ exp ] .)
    *               reduce using rule 37 (var -> prefixexp [ exp ] .)
    -               reduce using rule 37 (var -> prefixexp [ exp ] .)
    +               reduce using rule 37 (var -> prefixexp [ exp ] .)
    )               reduce using rule 37 (var -> prefixexp [ exp ] .)
    $end            reduce using rule 37 (var -> prefixexp [ exp ] .)
    UNTIL           reduce using rule 37 (var -> prefixexp [ exp ] .)
    ELSEIF          reduce using rule 37 (var -> prefixexp [ exp ] .)
    ELSE            reduce using rule 37 (var -> prefixexp [ exp ] .)
    END             reduce using rule 37 (var -> prefixexp [ exp ] .)
    ;               reduce using rule 37 (var -> prefixexp [ exp ] .)
    }               reduce using rule 37 (var -> prefixexp [ exp ] .)
    BREAK           reduce using rule 37 (var -> prefixexp [ exp ] .)
    RETURN          reduce using rule 37 (var -> prefixexp [ exp ] .)
    LOCAL           reduce using rule 37 (var -> prefixexp [ exp ] .)
    FUNCTION        reduce using rule 37 (var -> prefixexp [ exp ] .)
    FOR             reduce using rule 37 (var -> prefixexp [ exp ] .)
    IF              reduce using rule 37 (var -> prefixexp [ exp ] .)
    REPEAT          reduce using rule 37 (var -> prefixexp [ exp ] .)
    NAME            reduce using rule 37 (var -> prefixexp [ exp ] .)
    ]               reduce using rule 37 (var -> prefixexp [ exp ] .)
    DO              reduce using rule 37 (var -> prefixexp [ exp ] .)


state 164

    (79) args -> ( explist ) .
    ;               reduce using rule 79 (args -> ( explist ) .)
    BREAK           reduce using rule 79 (args -> ( explist ) .)
    RETURN          reduce using rule 79 (args -> ( explist ) .)
    LOCAL           reduce using rule 79 (args -> ( explist ) .)
    FUNCTION        reduce using rule 79 (args -> ( explist ) .)
    FOR             reduce using rule 79 (args -> ( explist ) .)
    IF              reduce using rule 79 (args -> ( explist ) .)
    REPEAT          reduce using rule 79 (args -> ( explist ) .)
    {               reduce using rule 79 (args -> ( explist ) .)
    (               reduce using rule 79 (args -> ( explist ) .)
    NAME            reduce using rule 79 (args -> ( explist ) .)
    :               reduce using rule 79 (args -> ( explist ) .)
    .               reduce using rule 79 (args -> ( explist ) .)
    [               reduce using rule 79 (args -> ( explist ) .)
    STRING          reduce using rule 79 (args -> ( explist ) .)
    THEN            reduce using rule 79 (args -> ( explist ) .)
    OR              reduce using rule 79 (args -> ( explist ) .)
    AND             reduce using rule 79 (args -> ( explist ) .)
    NE              reduce using rule 79 (args -> ( explist ) .)
    EQ              reduce using rule 79 (args -> ( explist ) .)
    GE              reduce using rule 79 (args -> ( explist ) .)
    GT              reduce using rule 79 (args -> ( explist ) .)
    LE              reduce using rule 79 (args -> ( explist ) .)
    LT              reduce using rule 79 (args -> ( explist ) .)
    CONCAT          reduce using rule 79 (args -> ( explist ) .)
    %               reduce using rule 79 (args -> ( explist ) .)
    ^               reduce using rule 79 (args -> ( explist ) .)
    /               reduce using rule 79 (args -> ( explist ) .)
    *               reduce using rule 79 (args -> ( explist ) .)
    -               reduce using rule 79 (args -> ( explist ) .)
    +               reduce using rule 79 (args -> ( explist ) .)
    )               reduce using rule 79 (args -> ( explist ) .)
    ,               reduce using rule 79 (args -> ( explist ) .)
    $end            reduce using rule 79 (args -> ( explist ) .)
    UNTIL           reduce using rule 79 (args -> ( explist ) .)
    ELSEIF          reduce using rule 79 (args -> ( explist ) .)
    ELSE            reduce using rule 79 (args -> ( explist ) .)
    END             reduce using rule 79 (args -> ( explist ) .)
    }               reduce using rule 79 (args -> ( explist ) .)
    ]               reduce using rule 79 (args -> ( explist ) .)
    DO              reduce using rule 79 (args -> ( explist ) .)


state 165

    (43) explist -> explist , exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    ,               reduce using rule 43 (explist -> explist , exp .)
    $end            reduce using rule 43 (explist -> explist , exp .)
    UNTIL           reduce using rule 43 (explist -> explist , exp .)
    ELSEIF          reduce using rule 43 (explist -> explist , exp .)
    ELSE            reduce using rule 43 (explist -> explist , exp .)
    END             reduce using rule 43 (explist -> explist , exp .)
    {               reduce using rule 43 (explist -> explist , exp .)
    ;               reduce using rule 43 (explist -> explist , exp .)
    BREAK           reduce using rule 43 (explist -> explist , exp .)
    RETURN          reduce using rule 43 (explist -> explist , exp .)
    LOCAL           reduce using rule 43 (explist -> explist , exp .)
    FUNCTION        reduce using rule 43 (explist -> explist , exp .)
    FOR             reduce using rule 43 (explist -> explist , exp .)
    IF              reduce using rule 43 (explist -> explist , exp .)
    REPEAT          reduce using rule 43 (explist -> explist , exp .)
    (               reduce using rule 43 (explist -> explist , exp .)
    NAME            reduce using rule 43 (explist -> explist , exp .)
    )               reduce using rule 43 (explist -> explist , exp .)
    DO              reduce using rule 43 (explist -> explist , exp .)
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 166

    (82) funcbody -> ( ) block . END
    END             shift and go to state 180


state 167

    (83) funcbody -> ( parlist ) . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 181
    chunk                          shift and go to state 51
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 168

    (85) parlist -> namelist , . VARARG
    (42) namelist -> namelist , . name
    (40) name -> . NAME
    VARARG          shift and go to state 182
    NAME            shift and go to state 17

    name                           shift and go to state 121

state 169

    (12) stat -> FOR namelist IN explist DO . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 183
    chunk                          shift and go to state 51
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 170

    (13) stat -> FOR name = exp , . exp , exp DO block END
    (14) stat -> FOR name = exp , . exp DO block END
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    name                           shift and go to state 6
    exp                            shift and go to state 184
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48

state 171

    (15) stat -> IF exp THEN block elseiflist . _else END
    (22) elseiflist -> elseiflist . elseif
    (25) _else -> . empty
    (26) _else -> . ELSE block
    (24) elseif -> . ELSEIF exp THEN block
    (100) empty -> .
    ELSE            shift and go to state 188
    ELSEIF          shift and go to state 174
    END             reduce using rule 100 (empty -> .)

    _else                          shift and go to state 185
    elseif                         shift and go to state 186
    empty                          shift and go to state 187

state 172

    (21) elseiflist -> empty .
    ELSE            reduce using rule 21 (elseiflist -> empty .)
    ELSEIF          reduce using rule 21 (elseiflist -> empty .)
    END             reduce using rule 21 (elseiflist -> empty .)


state 173

    (23) elseiflist -> elseif .
    ELSE            reduce using rule 23 (elseiflist -> elseif .)
    ELSEIF          reduce using rule 23 (elseiflist -> elseif .)
    END             reduce using rule 23 (elseiflist -> elseif .)


state 174

    (24) elseif -> ELSEIF . exp THEN block
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 189
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 175

    (91) fieldlist2 -> fieldlist2 fieldsep field .
    ;               reduce using rule 91 (fieldlist2 -> fieldlist2 fieldsep field .)
    ,               reduce using rule 91 (fieldlist2 -> fieldlist2 fieldsep field .)
    }               reduce using rule 91 (fieldlist2 -> fieldlist2 fieldsep field .)


state 176

    (94) field -> NAME = exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    ;               reduce using rule 94 (field -> NAME = exp .)
    ,               reduce using rule 94 (field -> NAME = exp .)
    }               reduce using rule 94 (field -> NAME = exp .)
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 177

    (95) field -> [ exp ] . = exp
    =               shift and go to state 190


state 178

    (17) stat -> { WHILE } exp { . DO } block { END }
    DO              shift and go to state 191


state 179

    (18) stat -> { DO } block { . END }
    END             shift and go to state 192


state 180

    (82) funcbody -> ( ) block END .
    ;               reduce using rule 82 (funcbody -> ( ) block END .)
    BREAK           reduce using rule 82 (funcbody -> ( ) block END .)
    RETURN          reduce using rule 82 (funcbody -> ( ) block END .)
    LOCAL           reduce using rule 82 (funcbody -> ( ) block END .)
    FUNCTION        reduce using rule 82 (funcbody -> ( ) block END .)
    FOR             reduce using rule 82 (funcbody -> ( ) block END .)
    IF              reduce using rule 82 (funcbody -> ( ) block END .)
    REPEAT          reduce using rule 82 (funcbody -> ( ) block END .)
    {               reduce using rule 82 (funcbody -> ( ) block END .)
    (               reduce using rule 82 (funcbody -> ( ) block END .)
    NAME            reduce using rule 82 (funcbody -> ( ) block END .)
    THEN            reduce using rule 82 (funcbody -> ( ) block END .)
    OR              reduce using rule 82 (funcbody -> ( ) block END .)
    AND             reduce using rule 82 (funcbody -> ( ) block END .)
    NE              reduce using rule 82 (funcbody -> ( ) block END .)
    EQ              reduce using rule 82 (funcbody -> ( ) block END .)
    GE              reduce using rule 82 (funcbody -> ( ) block END .)
    GT              reduce using rule 82 (funcbody -> ( ) block END .)
    LE              reduce using rule 82 (funcbody -> ( ) block END .)
    LT              reduce using rule 82 (funcbody -> ( ) block END .)
    CONCAT          reduce using rule 82 (funcbody -> ( ) block END .)
    %               reduce using rule 82 (funcbody -> ( ) block END .)
    ^               reduce using rule 82 (funcbody -> ( ) block END .)
    /               reduce using rule 82 (funcbody -> ( ) block END .)
    *               reduce using rule 82 (funcbody -> ( ) block END .)
    -               reduce using rule 82 (funcbody -> ( ) block END .)
    +               reduce using rule 82 (funcbody -> ( ) block END .)
    )               reduce using rule 82 (funcbody -> ( ) block END .)
    ,               reduce using rule 82 (funcbody -> ( ) block END .)
    $end            reduce using rule 82 (funcbody -> ( ) block END .)
    UNTIL           reduce using rule 82 (funcbody -> ( ) block END .)
    ELSEIF          reduce using rule 82 (funcbody -> ( ) block END .)
    ELSE            reduce using rule 82 (funcbody -> ( ) block END .)
    END             reduce using rule 82 (funcbody -> ( ) block END .)
    }               reduce using rule 82 (funcbody -> ( ) block END .)
    ]               reduce using rule 82 (funcbody -> ( ) block END .)
    DO              reduce using rule 82 (funcbody -> ( ) block END .)


state 181

    (83) funcbody -> ( parlist ) block . END
    END             shift and go to state 193


state 182

    (85) parlist -> namelist , VARARG .
    )               reduce using rule 85 (parlist -> namelist , VARARG .)


state 183

    (12) stat -> FOR namelist IN explist DO block . END
    END             shift and go to state 194


state 184

    (13) stat -> FOR name = exp , exp . , exp DO block END
    (14) stat -> FOR name = exp , exp . DO block END
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    ,               shift and go to state 195
    DO              shift and go to state 196
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 185

    (15) stat -> IF exp THEN block elseiflist _else . END
    END             shift and go to state 197


state 186

    (22) elseiflist -> elseiflist elseif .
    ELSE            reduce using rule 22 (elseiflist -> elseiflist elseif .)
    ELSEIF          reduce using rule 22 (elseiflist -> elseiflist elseif .)
    END             reduce using rule 22 (elseiflist -> elseiflist elseif .)


state 187

    (25) _else -> empty .
    END             reduce using rule 25 (_else -> empty .)


state 188

    (26) _else -> ELSE . block
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 198
    chunk                          shift and go to state 51
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 189

    (24) elseif -> ELSEIF exp . THEN block
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    THEN            shift and go to state 199
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 190

    (95) field -> [ exp ] = . exp
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    exp                            shift and go to state 200
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48
    name                           shift and go to state 6

state 191

    (17) stat -> { WHILE } exp { DO . } block { END }
    }               shift and go to state 201


state 192

    (18) stat -> { DO } block { END . }
    }               shift and go to state 202


state 193

    (83) funcbody -> ( parlist ) block END .
    ;               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    BREAK           reduce using rule 83 (funcbody -> ( parlist ) block END .)
    RETURN          reduce using rule 83 (funcbody -> ( parlist ) block END .)
    LOCAL           reduce using rule 83 (funcbody -> ( parlist ) block END .)
    FUNCTION        reduce using rule 83 (funcbody -> ( parlist ) block END .)
    FOR             reduce using rule 83 (funcbody -> ( parlist ) block END .)
    IF              reduce using rule 83 (funcbody -> ( parlist ) block END .)
    REPEAT          reduce using rule 83 (funcbody -> ( parlist ) block END .)
    {               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    (               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    NAME            reduce using rule 83 (funcbody -> ( parlist ) block END .)
    THEN            reduce using rule 83 (funcbody -> ( parlist ) block END .)
    OR              reduce using rule 83 (funcbody -> ( parlist ) block END .)
    AND             reduce using rule 83 (funcbody -> ( parlist ) block END .)
    NE              reduce using rule 83 (funcbody -> ( parlist ) block END .)
    EQ              reduce using rule 83 (funcbody -> ( parlist ) block END .)
    GE              reduce using rule 83 (funcbody -> ( parlist ) block END .)
    GT              reduce using rule 83 (funcbody -> ( parlist ) block END .)
    LE              reduce using rule 83 (funcbody -> ( parlist ) block END .)
    LT              reduce using rule 83 (funcbody -> ( parlist ) block END .)
    CONCAT          reduce using rule 83 (funcbody -> ( parlist ) block END .)
    %               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    ^               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    /               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    *               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    -               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    +               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    )               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    ,               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    $end            reduce using rule 83 (funcbody -> ( parlist ) block END .)
    UNTIL           reduce using rule 83 (funcbody -> ( parlist ) block END .)
    ELSEIF          reduce using rule 83 (funcbody -> ( parlist ) block END .)
    ELSE            reduce using rule 83 (funcbody -> ( parlist ) block END .)
    END             reduce using rule 83 (funcbody -> ( parlist ) block END .)
    }               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    ]               reduce using rule 83 (funcbody -> ( parlist ) block END .)
    DO              reduce using rule 83 (funcbody -> ( parlist ) block END .)


state 194

    (12) stat -> FOR namelist IN explist DO block END .
    ;               reduce using rule 12 (stat -> FOR namelist IN explist DO block END .)
    BREAK           reduce using rule 12 (stat -> FOR namelist IN explist DO block END .)
    RETURN          reduce using rule 12 (stat -> FOR namelist IN explist DO block END .)
    LOCAL           reduce using rule 12 (stat -> FOR namelist IN explist DO block END .)
    FUNCTION        reduce using rule 12 (stat -> FOR namelist IN explist DO block END .)
    FOR             reduce using rule 12 (stat -> FOR namelist IN explist DO block END .)
    IF              reduce using rule 12 (stat -> FOR namelist IN explist DO block END .)
    REPEAT          reduce using rule 12 (stat -> FOR namelist IN explist DO block END .)
    {               reduce using rule 12 (stat -> FOR namelist IN explist DO block END .)
    (               reduce using rule 12 (stat -> FOR namelist IN explist DO block END .)
    NAME            reduce using rule 12 (stat -> FOR namelist IN explist DO block END .)


state 195

    (13) stat -> FOR name = exp , exp , . exp DO block END
    (45) exp -> . # exp
    (46) exp -> . NOT exp
    (47) exp -> . - exp
    (48) exp -> . exp OR exp
    (49) exp -> . exp AND exp
    (50) exp -> . exp NE exp
    (51) exp -> . exp EQ exp
    (52) exp -> . exp GE exp
    (53) exp -> . exp GT exp
    (54) exp -> . exp LE exp
    (55) exp -> . exp LT exp
    (56) exp -> . exp CONCAT exp
    (57) exp -> . exp % exp
    (58) exp -> . exp ^ exp
    (59) exp -> . exp / exp
    (60) exp -> . exp * exp
    (61) exp -> . exp - exp
    (62) exp -> . exp + exp
    (63) exp -> . tableconstructor
    (64) exp -> . prefixexp
    (65) exp -> . function
    (66) exp -> . VARARG
    (67) exp -> . NIL
    (68) exp -> . NUMBER
    (69) exp -> . STRING
    (70) exp -> . TRUE
    (71) exp -> . FALSE
    (88) tableconstructor -> . { }
    (89) tableconstructor -> . { fieldlist }
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (81) function -> . FUNCTION funcbody
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    #               shift and go to state 34
    NOT             shift and go to state 35
    -               shift and go to state 36
    VARARG          shift and go to state 40
    NIL             shift and go to state 41
    NUMBER          shift and go to state 42
    STRING          shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    {               shift and go to state 46
    (               shift and go to state 15
    FUNCTION        shift and go to state 49
    NAME            shift and go to state 17

    name                           shift and go to state 6
    exp                            shift and go to state 203
    tableconstructor               shift and go to state 37
    prefixexp                      shift and go to state 38
    function                       shift and go to state 39
    functioncall                   shift and go to state 47
    var                            shift and go to state 48

state 196

    (14) stat -> FOR name = exp , exp DO . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    name                           shift and go to state 6
    block                          shift and go to state 204
    chunk                          shift and go to state 51
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 197

    (15) stat -> IF exp THEN block elseiflist _else END .
    ;               reduce using rule 15 (stat -> IF exp THEN block elseiflist _else END .)
    BREAK           reduce using rule 15 (stat -> IF exp THEN block elseiflist _else END .)
    RETURN          reduce using rule 15 (stat -> IF exp THEN block elseiflist _else END .)
    LOCAL           reduce using rule 15 (stat -> IF exp THEN block elseiflist _else END .)
    FUNCTION        reduce using rule 15 (stat -> IF exp THEN block elseiflist _else END .)
    FOR             reduce using rule 15 (stat -> IF exp THEN block elseiflist _else END .)
    IF              reduce using rule 15 (stat -> IF exp THEN block elseiflist _else END .)
    REPEAT          reduce using rule 15 (stat -> IF exp THEN block elseiflist _else END .)
    {               reduce using rule 15 (stat -> IF exp THEN block elseiflist _else END .)
    (               reduce using rule 15 (stat -> IF exp THEN block elseiflist _else END .)
    NAME            reduce using rule 15 (stat -> IF exp THEN block elseiflist _else END .)


state 198

    (26) _else -> ELSE block .
    END             reduce using rule 26 (_else -> ELSE block .)


state 199

    (24) elseif -> ELSEIF exp THEN . block
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 205
    chunk                          shift and go to state 51
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 200

    (95) field -> [ exp ] = exp .
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    ;               reduce using rule 95 (field -> [ exp ] = exp .)
    ,               reduce using rule 95 (field -> [ exp ] = exp .)
    }               reduce using rule 95 (field -> [ exp ] = exp .)
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 201

    (17) stat -> { WHILE } exp { DO } . block { END }
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    block                          shift and go to state 206
    chunk                          shift and go to state 51
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    name                           shift and go to state 6
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 202

    (18) stat -> { DO } block { END } .
    ;               reduce using rule 18 (stat -> { DO } block { END } .)
    BREAK           reduce using rule 18 (stat -> { DO } block { END } .)
    RETURN          reduce using rule 18 (stat -> { DO } block { END } .)
    LOCAL           reduce using rule 18 (stat -> { DO } block { END } .)
    FUNCTION        reduce using rule 18 (stat -> { DO } block { END } .)
    FOR             reduce using rule 18 (stat -> { DO } block { END } .)
    IF              reduce using rule 18 (stat -> { DO } block { END } .)
    REPEAT          reduce using rule 18 (stat -> { DO } block { END } .)
    {               reduce using rule 18 (stat -> { DO } block { END } .)
    (               reduce using rule 18 (stat -> { DO } block { END } .)
    NAME            reduce using rule 18 (stat -> { DO } block { END } .)


state 203

    (13) stat -> FOR name = exp , exp , exp . DO block END
    (48) exp -> exp . OR exp
    (49) exp -> exp . AND exp
    (50) exp -> exp . NE exp
    (51) exp -> exp . EQ exp
    (52) exp -> exp . GE exp
    (53) exp -> exp . GT exp
    (54) exp -> exp . LE exp
    (55) exp -> exp . LT exp
    (56) exp -> exp . CONCAT exp
    (57) exp -> exp . % exp
    (58) exp -> exp . ^ exp
    (59) exp -> exp . / exp
    (60) exp -> exp . * exp
    (61) exp -> exp . - exp
    (62) exp -> exp . + exp
    DO              shift and go to state 207
    OR              shift and go to state 80
    AND             shift and go to state 81
    NE              shift and go to state 82
    EQ              shift and go to state 83
    GE              shift and go to state 84
    GT              shift and go to state 85
    LE              shift and go to state 86
    LT              shift and go to state 87
    CONCAT          shift and go to state 88
    %               shift and go to state 89
    ^               shift and go to state 90
    /               shift and go to state 91
    *               shift and go to state 92
    -               shift and go to state 93
    +               shift and go to state 94


state 204

    (14) stat -> FOR name = exp , exp DO block . END
    END             shift and go to state 208


state 205

    (24) elseif -> ELSEIF exp THEN block .
    ELSE            reduce using rule 24 (elseif -> ELSEIF exp THEN block .)
    ELSEIF          reduce using rule 24 (elseif -> ELSEIF exp THEN block .)
    END             reduce using rule 24 (elseif -> ELSEIF exp THEN block .)


state 206

    (17) stat -> { WHILE } exp { DO } block . { END }
    {               shift and go to state 209


state 207

    (13) stat -> FOR name = exp , exp , exp DO . block END
    (4) block -> . chunk
    (1) chunk -> . chunk2 laststat
    (2) chunk2 -> . chunk2 stat optsemi
    (3) chunk2 -> . stat optsemi
    (7) stat -> . LOCAL namelist = explist
    (8) stat -> . LOCAL namelist
    (9) stat -> . LOCAL FUNCTION name funcbody
    (10) stat -> . FUNCTION funcname args
    (11) stat -> . FUNCTION funcname funcbody
    (12) stat -> . FOR namelist IN explist DO block END
    (13) stat -> . FOR name = exp , exp , exp DO block END
    (14) stat -> . FOR name = exp , exp DO block END
    (15) stat -> . IF exp THEN block elseiflist _else END
    (16) stat -> . REPEAT block UNTIL exp
    (17) stat -> . { WHILE } exp { DO } block { END }
    (18) stat -> . { DO } block { END }
    (19) stat -> . functioncall
    (20) stat -> . location = explist
    (75) functioncall -> . prefixexp : name args
    (76) functioncall -> . prefixexp args
    (39) location -> . varlist
    (72) prefixexp -> . ( exp )
    (73) prefixexp -> . functioncall
    (74) prefixexp -> . var
    (34) varlist -> . var
    (35) varlist -> . varlist , var
    (36) var -> . prefixexp . name
    (37) var -> . prefixexp [ exp ]
    (38) var -> . name
    (40) name -> . NAME
    LOCAL           shift and go to state 4
    FUNCTION        shift and go to state 5
    FOR             shift and go to state 7
    IF              shift and go to state 8
    REPEAT          shift and go to state 9
    {               shift and go to state 10
    (               shift and go to state 15
    NAME            shift and go to state 17

    name                           shift and go to state 6
    block                          shift and go to state 210
    chunk                          shift and go to state 51
    chunk2                         shift and go to state 2
    stat                           shift and go to state 3
    functioncall                   shift and go to state 11
    location                       shift and go to state 12
    prefixexp                      shift and go to state 13
    varlist                        shift and go to state 14
    var                            shift and go to state 16

state 208

    (14) stat -> FOR name = exp , exp DO block END .
    ;               reduce using rule 14 (stat -> FOR name = exp , exp DO block END .)
    BREAK           reduce using rule 14 (stat -> FOR name = exp , exp DO block END .)
    RETURN          reduce using rule 14 (stat -> FOR name = exp , exp DO block END .)
    LOCAL           reduce using rule 14 (stat -> FOR name = exp , exp DO block END .)
    FUNCTION        reduce using rule 14 (stat -> FOR name = exp , exp DO block END .)
    FOR             reduce using rule 14 (stat -> FOR name = exp , exp DO block END .)
    IF              reduce using rule 14 (stat -> FOR name = exp , exp DO block END .)
    REPEAT          reduce using rule 14 (stat -> FOR name = exp , exp DO block END .)
    {               reduce using rule 14 (stat -> FOR name = exp , exp DO block END .)
    (               reduce using rule 14 (stat -> FOR name = exp , exp DO block END .)
    NAME            reduce using rule 14 (stat -> FOR name = exp , exp DO block END .)


state 209

    (17) stat -> { WHILE } exp { DO } block { . END }
    END             shift and go to state 211


state 210

    (13) stat -> FOR name = exp , exp , exp DO block . END
    END             shift and go to state 212


state 211

    (17) stat -> { WHILE } exp { DO } block { END . }
    }               shift and go to state 213


state 212

    (13) stat -> FOR name = exp , exp , exp DO block END .
    ;               reduce using rule 13 (stat -> FOR name = exp , exp , exp DO block END .)
    BREAK           reduce using rule 13 (stat -> FOR name = exp , exp , exp DO block END .)
    RETURN          reduce using rule 13 (stat -> FOR name = exp , exp , exp DO block END .)
    LOCAL           reduce using rule 13 (stat -> FOR name = exp , exp , exp DO block END .)
    FUNCTION        reduce using rule 13 (stat -> FOR name = exp , exp , exp DO block END .)
    FOR             reduce using rule 13 (stat -> FOR name = exp , exp , exp DO block END .)
    IF              reduce using rule 13 (stat -> FOR name = exp , exp , exp DO block END .)
    REPEAT          reduce using rule 13 (stat -> FOR name = exp , exp , exp DO block END .)
    {               reduce using rule 13 (stat -> FOR name = exp , exp , exp DO block END .)
    (               reduce using rule 13 (stat -> FOR name = exp , exp , exp DO block END .)
    NAME            reduce using rule 13 (stat -> FOR name = exp , exp , exp DO block END .)


state 213

    (17) stat -> { WHILE } exp { DO } block { END } .
    ;               reduce using rule 17 (stat -> { WHILE } exp { DO } block { END } .)
    BREAK           reduce using rule 17 (stat -> { WHILE } exp { DO } block { END } .)
    RETURN          reduce using rule 17 (stat -> { WHILE } exp { DO } block { END } .)
    LOCAL           reduce using rule 17 (stat -> { WHILE } exp { DO } block { END } .)
    FUNCTION        reduce using rule 17 (stat -> { WHILE } exp { DO } block { END } .)
    FOR             reduce using rule 17 (stat -> { WHILE } exp { DO } block { END } .)
    IF              reduce using rule 17 (stat -> { WHILE } exp { DO } block { END } .)
    REPEAT          reduce using rule 17 (stat -> { WHILE } exp { DO } block { END } .)
    {               reduce using rule 17 (stat -> { WHILE } exp { DO } block { END } .)
    (               reduce using rule 17 (stat -> { WHILE } exp { DO } block { END } .)
    NAME            reduce using rule 17 (stat -> { WHILE } exp { DO } block { END } .)


Conflicts:

shift/reduce conflict for { in state 21 resolved as shift
shift/reduce conflict for ( in state 38 resolved as shift
shift/reduce conflict for { in state 38 resolved as shift
shift/reduce conflict for ) in state 74 resolved as shift
shift/reduce conflict for ) in state 106 resolved as shift
shift/reduce conflict for LOCAL in state 123 resolved as shift
shift/reduce conflict for FUNCTION in state 123 resolved as shift
shift/reduce conflict for FOR in state 123 resolved as shift
shift/reduce conflict for IF in state 123 resolved as shift
shift/reduce conflict for REPEAT in state 123 resolved as shift
shift/reduce conflict for { in state 123 resolved as shift
shift/reduce conflict for ( in state 123 resolved as shift
shift/reduce conflict for NAME in state 123 resolved as shift
shift/reduce conflict for ELSEIF in state 133 resolved as shift
reduce/reduce conflict in state 11 resolved using rule stat -> functioncall
rejected rule (prefixexp -> functioncall) in state 11
reduce/reduce conflict in state 125 resolved using rule exp -> VARARG
rejected rule (parlist -> VARARG) in state 125
reduce/reduce conflict in state 128 resolved using rule var -> name
rejected rule (namelist -> name) in state 128